diff --git .gitignore .gitignore
index a625419..f35cda7 100644
--- .gitignore
+++ .gitignore
@@ -1,6 +1,5 @@
 .DS_Store
 zips
 packages
-Plex/manifest
 Plex/roku_screenshot.jpg
 screenshots
diff --git Plex/Makefile Plex/Makefile
index caf4463..d22d965 100644
--- Plex/Makefile
+++ Plex/Makefile
@@ -29,18 +29,19 @@ num_functions := $(shell grep -ri --include=*.brs 'end \(function\|sub\)' . | wc
 beta: APPTITLE = PlexBeta
 beta: $(APPNAME)
 
-test: APPTITLE = PlexTest
+test: APPTITLE = RARflixTest
 test: $(APPNAME)
 
 dev: APPTITLE = PlexDev
 dev: $(APPNAME)
 
-rel: APPTITLE = Plex
+rel: APPTITLE = RARflix
 rel: $(APPNAME)
 
 rarflix: APPTITLE = RARflix
 rarflix: $(APPNAME)
 
+
 manifest:
 	echo "Creating manifest for $(APPTITLE)"
 #	sed s/APPTITLE/$(APPTITLE)/ < manifest.template > manifest
diff --git Plex/manifest.rarflix.template Plex/manifest.rarflix.template
index 1a22c67..401d927 100644
--- Plex/manifest.rarflix.template
+++ Plex/manifest.rarflix.template
@@ -1,8 +1,8 @@
 title=APPTITLE
-version=2.6.8
+version=2.6.9
 major_version=2
 minor_version=6
-build_version=8
+build_version=9
 subtitle=The best personal and online content streaming app!
 description=Plex delivers the best video, music and photo streaming media experience that connects you to any online or personal content--including movies, TV shows, videos, music and photos.  Plex for Roku works with myPlex and the your personal Plex Media Server enabling Plex Channels, Social Sharing, and Queueing of content.
 mm_icon_focus_hd=pkg:/images/plex-logo-hd-rarflix.jpg
diff --git Plex/source/GridScreen.brs Plex/source/GridScreen.brs
index 99d41e5..cad2e8f 100644
--- Plex/source/GridScreen.brs
+++ Plex/source/GridScreen.brs
@@ -54,6 +54,7 @@ Function createGridScreenForItem(item, viewController, style) As Object
 
     container = createPlexContainerForUrl(item.server, item.sourceUrl, item.key)
     container.SeparateSearchItems = true
+    ' ljunkie -- testing lazy load (TODO)
     obj.Loader = createPaginatedLoader(container, 8, 75)
     obj.Loader.Listener = obj
 
diff --git Plex/source/KeyboardScreen.brs Plex/source/KeyboardScreen.brs
index 787dce2..86c0177 100644
--- Plex/source/KeyboardScreen.brs
+++ Plex/source/KeyboardScreen.brs
@@ -50,7 +50,7 @@ Function kbHandleMessage(msg) As Boolean
                     m.Text = m.Screen.GetText()
                     if m.Listener <> invalid then
                         m.Listener.OnUserInput(m.Text, m)
-                    else
+                    else if m.Item <> invalid then
                         callback = CreateObject("roAssociativeArray")
                         callback.Heading = m.Text
                         callback.Item = CreateObject("roAssociativeArray")
diff --git Plex/source/MetadataUtils.brs Plex/source/MetadataUtils.brs
index d39a54a..a440c63 100644
--- Plex/source/MetadataUtils.brs
+++ Plex/source/MetadataUtils.brs
@@ -59,6 +59,33 @@ Function createBaseMetadata(container, item, thumb=invalid) As Object
 
     metadata.sourceTitle = item@sourceTitle
 
+    ' START: ljunkie - leafCount viewedLeafCount ( how many items, how many items watched)
+    if item@leafCount <> invalid  then
+       metadata.leafCount = item@leafCount
+    end if
+
+    if item@viewedLeafCount <> invalid  then
+       metadata.viewedLeafCount = item@viewedLeafCount
+    end if
+
+    ' appent title differently based on leaf/viewed
+    ' I might what to check the type here - not sure how this looks for types other than shows (TODO)
+    if item@viewedLeafCount <> invalid and item@leafCount <> invalid 
+       extra = invalid
+       if val(item@viewedLeafCount) = val(item@leafCount) then
+            extra = " (watched)" ' all items watched
+       else if val(item@viewedLeafCount) > 0 then
+            extra = " (" + tostr(item@viewedLeafCount) + " of " + tostr(item@leafCount) + " watched)" ' partially watched - show count
+       else if val(item@leafCount) > 0 then
+            extra = " (" + tostr(item@leafCount) + ")"
+       end if
+       if extra <> invalid then
+           metadata.Title = metadata.Title + extra
+           metadata.ShortDescriptionLine1 = metadata.ShortDescriptionLine1 + extra
+       end if
+    end if
+    ' END: ljunkie - leafCount viewedLeafCount ( how many items, how many items watched)
+
     if container.xml@mixedParents = "1" then
         parentTitle = firstOf(item@parentTitle, container.xml@parentTitle, "")
         if parentTitle <> "" then
diff --git Plex/source/MyPlexManager.brs Plex/source/MyPlexManager.brs
index 3018625..ea7aff5 100644
--- Plex/source/MyPlexManager.brs
+++ Plex/source/MyPlexManager.brs
@@ -184,7 +184,7 @@ Sub mpDelete(id)
         Debug("Executing delete command: " + commandUrl)
         request = m.CreateRequest("", commandUrl)
         request.PostFromString("_method=DELETE")
-    end if
+     end if
 End Sub
 
 Function mpExecuteCommand(commandPath)
diff --git Plex/source/PlexMediaServer.brs Plex/source/PlexMediaServer.brs
index 7209f7a..800b447 100644
--- Plex/source/PlexMediaServer.brs
+++ Plex/source/PlexMediaServer.brs
@@ -576,9 +576,19 @@ Function TranscodingVideoUrl(videoUrl As String, item As Object, httpHeaders As
     ' here.
 
     ' The universal transcoder doesn't support old school XML with no Media
-    ' elements, so check for that and use the old transcoder.
+    ' elements, so check for that and use the old transcoder. It also won't
+    ' work when analysis fails and there are no streams. The old transcoder
+    ' may not work with those files anyway, but the universal transcoder will
+    ' definitely fail.
 
-    if item.preferredMediaItem <> invalid AND m.SupportsUniversalTranscoding AND RegRead("transcoder_version", "preferences", "universal") = "universal" then
+    hasStreams = false
+    if item.preferredMediaItem <> invalid then
+        if item.preferredMediaItem.preferredPart <> invalid then
+            hasStreams = (item.preferredMediaItem.preferredPart.streams.Count() > 0)
+        end if
+    end if
+
+    if hasStreams AND m.SupportsUniversalTranscoding AND RegRead("transcoder_version", "preferences", "universal") = "universal" then
         return m.UniversalTranscodingVideoUrl(videoUrl, item, seekValue)
     else
         return m.ClassicTranscodingVideoUrl(videoUrl, item, httpHeaders)
@@ -809,9 +819,7 @@ Function Capabilities(recompute=false) As String
     ' signal through and theoretically doesn't care if it's 7.1.
     if SupportsSurroundSound(true, true) then
         fiveone = RegRead("fivepointone", "preferences", "1")
-        fiveoneDCA = RegRead("fivepointoneDCA", "preferences", "1")
         Debug("5.1 support set to: " + fiveone)
-        Debug("5.1 DTS support set to: " + fiveoneDCA)
 
         if fiveone <> "2" then
             audio = audio + ",ac3{channels:8}"
diff --git Plex/source/PreferenceScreen.brs Plex/source/PreferenceScreen.brs
index 8535cc0..0073736 100644
--- Plex/source/PreferenceScreen.brs
+++ Plex/source/PreferenceScreen.brs
@@ -252,6 +252,19 @@ Function createPreferencesScreen(viewController) As Object
         default: "disabled"
     }
 
+    ' Trailers
+    trailers = [
+        { title: "Enabled TMDB & Youtube", EnumValue: "enabled", ShortDescriptionLine2: "Get Movies Trailers" },
+        { title: "Enabled TMDB w/ Youtube Fallback", EnumValue: "enabled_tmdb_ytfb" }
+        { title: "Disabled", EnumValue: "disabled"}
+
+    ]
+    obj.Prefs["trailers"] = {
+        values: trailers,
+        heading: "Movie Trailers",
+        default: "enabled_tmdb_yt"
+    }
+
     obj.myplex = GetGlobalAA().Lookup("myplex")
     obj.checkMyPlexOnActivate = false
 
@@ -271,6 +284,7 @@ Sub showPreferencesScreen()
     m.AddItem({title: "Quality"}, "quality", m.GetEnumValue("quality"))
     m.AddItem({title: "Remote Quality"}, "quality_remote", m.GetEnumValue("quality_remote"))
     m.AddItem({title: "Rotten Tomatoes"}, "rottentomatoes", m.GetEnumValue("rottentomatoes"))
+    m.AddItem({title: "Movie Trailers"}, "trailers", m.GetEnumValue("trailers"))
     m.AddItem({title: "Direct Play"}, "directplay", m.GetEnumValue("directplay"))
     m.AddItem({title: "Audio Preferences"}, "audio_prefs")
     m.AddItem({title: "Home Screen"}, "homescreen")
@@ -352,7 +366,7 @@ Function prefsMainHandleMessage(msg) As Boolean
                     screen.Show()
                 end if
             ' removed 5.1 (finepointone) -- moved to audio prefs RR
-            else if command = "quality" OR command = "quality_remote" OR command = "level" OR command = "directplay" OR command = "screensaver" OR command = "rottentomatoes" then
+            else if command = "quality" OR command = "quality_remote" OR command = "level" OR command = "directplay" OR command = "screensaver" OR command = "rottentomatoes" OR command = "trailers" then
                 m.HandleEnumPreference(command, msg.GetIndex())
             else if command = "slideshow" then
                 screen = createSlideshowPrefsScreen(m.ViewController)
@@ -591,7 +605,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
         default: "40"
     }
 
-
     ' HLS seconds per segment
     lengths = [
         { title: "Automatic", EnumValue: "auto", ShortDescriptionLine2: "Chooses based on quality." },
@@ -604,7 +617,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
         default: "10"
     }
 
-
     ' Analytics (opt-out)
     values = [
         { title: "Enabled", EnumValue: "1" },
@@ -625,7 +637,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
     obj.AddItem({title: "Continuous Play"}, "continuous_play", obj.GetEnumValue("continuous_play"))
     obj.AddItem({title: "H.264"}, "level", obj.GetEnumValue("level"))
 
-
     if GetGlobal("legacy1080p") then
         obj.AddItem({title: "1080p Settings"}, "1080p")
     end if
@@ -753,59 +764,55 @@ Function createAudioPrefsScreen(viewController) As Object
         default: "loop"
     }
 
-    ' Audio boost for transcoded content. Transcoded content is quiet by
-    ' default, but if we set a default boost then audio will never be remuxed.
-    ' These values are based on iOS.
-    ' moved into Audio Preferences - RR
-    values = [
-        { title: "None", EnumValue: "100" },
-        { title: "Small", EnumValue: "175" },
-        { title: "Large", EnumValue: "225" },
-        { title: "Huge", EnumValue: "300" }
-    ]
-    obj.Prefs["audio_boost"] = {
-        values: values,
-        heading: "Audio boost for transcoded video",
-        default: "100"
-    }
-
-
-    ' 5.1 Support
-    ' moved into Audio Preferences - RR
+    ' 5.1 Support - AC-3
     fiveone = [
         { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to copy 5.1 audio streams when transcoding." },
         { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Always use 2-channel audio when transcoding." }
     ]
     obj.Prefs["fivepointone"] = {
         values: fiveone,
-        heading: "5.1 audio support for transcoded content",
+        heading: "5.1 AC-3 support",
         default: "1"
     }
 
-
-    ' DTS support - Added by RR
-    ' moved into Audio Preferences - RR
+    ' 5.1 Support - DTS
     fiveoneDCA = [
-        { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to copy DTS audio streams when transcoding." },
-        { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Always use 2-channel audio when transcoding." }
+        { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to Direct Play DTS in MKVs." },
+        { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Never Direct Play DTS." }
     ]
     obj.Prefs["fivepointoneDCA"] = {
         values: fiveoneDCA,
-        heading: "DTS audio support for transcoded content",
+        heading: "5.1 DTS support",
         default: "1"
     }
 
+    ' Audio boost for transcoded content. Transcoded content is quiet by
+    ' default, but if we set a default boost then audio will never be remuxed.
+    ' These values are based on iOS.
+    values = [
+        { title: "None", EnumValue: "100" },
+        { title: "Small", EnumValue: "175" },
+        { title: "Large", EnumValue: "225" },
+        { title: "Huge", EnumValue: "300" }
+    ]
+    obj.Prefs["audio_boost"] = {
+        values: values,
+        heading: "Audio boost for transcoded video",
+        default: "100"
+    }
 
     obj.Screen.SetHeader("Audio Preferences")
 
     obj.AddItem({title: "Loop Playback"}, "loopalbums", obj.GetEnumValue("loopalbums"))
     obj.AddItem({title: "Theme Music"}, "theme_music", obj.GetEnumValue("theme_music"))
-    obj.AddItem({title: "Audio Boost"}, "audio_boost", obj.GetEnumValue("audio_boost"))
+
     if SupportsSurroundSound(true) then
-        obj.AddItem({title: "5.1 Support"}, "fivepointone", obj.GetEnumValue("fivepointone"))
+        obj.AddItem({title: "5.1 AC-3 Support"}, "fivepointone", obj.GetEnumValue("fivepointone"))
         obj.AddItem({title: "5.1 DTS Support"}, "fivepointoneDCA", obj.GetEnumValue("fivepointoneDCA"))
     end if
 
+    obj.AddItem({title: "Audio Boost"}, "audio_boost", obj.GetEnumValue("audio_boost"))
+
     obj.AddItem({title: "Close"}, "close")
 
     return obj
@@ -821,12 +828,10 @@ Function prefsAudioHandleMessage(msg) As Boolean
             m.ViewController.PopScreen(m)
         else if msg.isListItemSelected() then
             command = m.GetSelectedCommand(msg.GetIndex())
-            ' Moved DTS, 5.1 and Audio Boost into audio Prefs RR
-            ' OLD: if command = "loopalbums" OR command = "theme_music" then
-            if command = "loopalbums" OR command = "theme_music" OR command = "fivepointone" OR command = "fivepointoneDCA" OR command = "audio_boost" then
-                m.HandleEnumPreference(command, msg.GetIndex())
-            else if command = "close" then
+            if command = "close" then
                 m.Screen.Close()
+            else
+                m.HandleEnumPreference(command, msg.GetIndex())
             end if
         end if
     end if
diff --git Plex/source/VideoMetadata.brs Plex/source/VideoMetadata.brs
index 9e24fb2..cd5c76b 100644
--- Plex/source/VideoMetadata.brs
+++ Plex/source/VideoMetadata.brs
@@ -66,6 +66,7 @@ Function newVideoMetadata(container, item, detailed=false) As Object
 End Function
 
 Sub setVideoBasics(video, container, item)
+
     video.viewOffset = item@viewOffset
     video.viewCount = item@viewCount
     video.Watched = video.viewCount <> invalid AND val(video.viewCount) > 0
@@ -144,7 +145,9 @@ Sub setVideoBasics(video, container, item)
 
     ' if a video has ever been watch mark as such, else mark partially if there's a recorded
     ' offset
-    if video.Watched then
+    if video.Watched AND video.viewOffset <> invalid AND val(video.viewOffset) > 0 then
+        video.ShortDescriptionLine1 = video.ShortDescriptionLine1 + " (Watched + Partially Watched)"
+    else if video.Watched then
         video.ShortDescriptionLine1 = video.ShortDescriptionLine1 + " (Watched)"
     else if video.viewOffset <> invalid AND val(video.viewOffset) > 0 then
         video.ShortDescriptionLine1 = video.ShortDescriptionLine1 + " (Partially Watched)"
diff --git Plex/source/VideoPlayer.brs Plex/source/VideoPlayer.brs
index b4f5092..9b131c8 100644
--- Plex/source/VideoPlayer.brs
+++ Plex/source/VideoPlayer.brs
@@ -138,6 +138,9 @@ Function videoPlayerCreateVideoPlayer()
     end if
 
     videoItem.OrigReleaseDate = videoItem.ReleaseDate
+
+    videoItem.Duration = mediaItem.duration ' set duration - used for EndTime/TimeLeft on HUD  - ljunkie
+
     if videoItem.IsTranscoded then
         server = videoItem.TranscodeServer
         videoItem.ReleaseDate = videoItem.ReleaseDate + "   Transcoded"
@@ -148,7 +151,7 @@ Function videoPlayerCreateVideoPlayer()
            if (videoItem.audioCh.toint() = 6) then
                audioCh = "5.1"
            else
-               audioCh = tostr(videoItem.audioCh) + "ch"
+              audioCh = tostr(videoItem.audioCh) + "ch"
            end if
        end if
 
@@ -309,6 +312,37 @@ Function videoPlayerHandleMessage(msg) As Boolean
             end if
             m.playState = "playing"
             m.SendTimeline(true)
+
+            ' START: EndTime and Time Left to HUD - ljunkie
+	    if msg.GetIndex() > 0 AND m.VideoItem.Duration > 0 then
+	        'printAA(m.VideoItem)
+                duration = int(m.VideoItem.Duration/1000)
+                date = CreateObject("roDateTime")
+                timeLeft = int(Duration - msg.GetIndex())
+                endString = RRmktime(date.AsSeconds()+timeLeft)
+                endString = endString + " (" + GetDurationString(timeLeft,0,1,1) + ")" 'always show min/secs
+
+		' set the HUD
+                content = CreateObject("roAssociativeArray")
+                content = m.VideoItem ' assign Video item and reset other keys
+		if m.VideoItem.OrigHUDreleaseDate = invalid then
+                   m.VideoItem.OrigHUDreleaseDate = m.VideoItem.releasedate
+                end if
+                content.length = m.VideoItem.duration
+                content.title = m.VideoItem.title
+
+		if tostr(m.VideoItem.rokustreambitrate) <> "invalid" then
+	  	    bitrate = RRbitrate(m.VideoItem.rokustreambitrate)
+		    'if tostr(m.videoItem.IsTranscoded) = "false" then
+                        'bitrate = chr(10) + bitrate ' put bitrate on a new line -- string might be too long
+		    'end if
+                    content.releasedate = m.VideoItem.OrigHUDreleasedate + " " + bitrate
+                end if
+                content.releasedate = content.releasedate + chr(10) + chr(10) + "End Time: " + endString 'two line breaks - easier to read ( yea it makes the hug larger...)                     
+		' update HUD
+                m.Screen.SetContent(content)
+            end if
+            ' END: EndTime/TimeLeft HUD - ljunkie
         else if msg.isRequestFailed() then
             Debug("MediaPlayer::playVideo::VideoScreenEvent::isRequestFailed - message = " + tostr(msg.GetMessage()))
             Debug("MediaPlayer::playVideo::VideoScreenEvent::isRequestFailed - data = " + tostr(msg.GetData()))
@@ -336,7 +370,8 @@ Function videoPlayerHandleMessage(msg) As Boolean
         else if msg.isStreamStarted() then
             Debug("MediaPlayer::playVideo::VideoScreenEvent::isStreamStarted: position -> " + tostr(m.lastPosition))
             Debug("Message data -> " + tostr(msg.GetInfo()))
-
+	    'printAA(msg.GetInfo())
+	    m.VideoItem.rokuStreamBitrate = msg.GetInfo().StreamBitrate
             m.StartTranscodeSessionRequest()
 
             if msg.GetInfo().IsUnderrun = true then
@@ -421,8 +456,9 @@ Sub videoPlayerOnUrlEvent(msg, requestContext)
                     audio = "copy"
                 end if
 
-                m.VideoItem.ReleaseDate = m.VideoItem.OrigReleaseDate + chr(10) + "video: " + video  + chr(10) + " audio: " + audio + chr(10) + videoRes + " " + audioChannel
-                ' + curState -- doesn't seem useful
+                m.VideoItem.ReleaseDate = m.VideoItem.OrigReleaseDate + "   Transcoded " + " (" + videoRes + " " + audioChannel + ")" +chr(10)  + "video: " + video  + " audio: " + audio 
+                ' + curState -- doesn't seem useful - this doesn't get updated on the fly, useful if moved to: videoPlayerHandleMessage -> msg.isPlaybackPosition
+
                 m.VideoPlayer.SetContent(m.VideoItem)
             end if
 	end if
@@ -490,6 +526,8 @@ Function videoCanDirectPlay(mediaItem) As Boolean
     end if
     mediaItem.canDirectPlay = false
     mediaItem.cachedSurroundSound = surroundSound
+    surroundSoundDCA = surroundSound AND (RegRead("fivepointoneDCA", "preferences", "1") = "1")
+    surroundSound = surroundSound AND (RegRead("fivepointone", "preferences", "1") = "1")
 
     if mediaItem.preferredPart <> invalid AND mediaItem.preferredPart.subtitles <> invalid then
         subtitleStream = mediaItem.preferredPart.subtitles
@@ -552,14 +590,6 @@ Function videoCanDirectPlay(mediaItem) As Boolean
         next
     end if
 
-    ' RR - for some reason fling video from iPhone to Roku skips code above let's set the surroundCodec to mediaItem.audioCodec if it's still invalid 
-    ' TODO @ http://forums.plexapp.com/index.php/topic/79460-fling-direct-play-broken-from-iphone-dca-codec/
-    if surroundCodec = invalid then
-           surroundCodec = mediaItem.audioCodec
-    end if
-    fiveoneDCA = RegRead("fivepointoneDCA", "preferences", "1")
-    Debug("DTS support set to  " + fiveoneDCA)
-
     Debug("Media item optimized for streaming: " + tostr(mediaItem.optimized))
     Debug("Media item container: " + tostr(mediaItem.container))
     Debug("Media item video codec: " + tostr(mediaItem.videoCodec))
@@ -619,16 +649,16 @@ Function videoCanDirectPlay(mediaItem) As Boolean
             return false
         end if
 
-        if surroundStreamFirst AND surroundCodec = "aac" then
-            Debug("videoCanDirectPlay: first audio stream is 5.1 AAC")
-            return false
-        end if
-
         if surroundSound AND (surroundCodec = "ac3" OR stereoCodec = "ac3") then
             mediaItem.canDirectPlay = true
             return true
         end if
 
+        if surroundStreamFirst then
+            Debug("videoCanDirectPlay: first audio stream is unsupported 5.1")
+            return false
+        end if
+
         if stereoCodec = "aac" then
             mediaItem.canDirectPlay = true
             return true
@@ -695,15 +725,19 @@ Function videoCanDirectPlay(mediaItem) As Boolean
             end if
         end if
 
-        if surroundSound then
-            if (surroundCodec = "ac3" OR stereoCodec = "ac3") then
-                mediaItem.canDirectPlay = true
-                return true
-            end if
-            if (fiveoneDCA <> "2" AND surroundCodec = "dca") then
-                mediaItem.canDirectPlay = true
-                return true
-            end if
+        if surroundSound AND (surroundCodec = "ac3" OR stereoCodec = "ac3") then
+            mediaItem.canDirectPlay = true
+            return true
+        end if
+
+        if surroundSoundDCA AND (surroundCodec = "dca" OR stereoCodec = "dca") then
+            mediaItem.canDirectPlay = true
+            return true
+        end if
+
+        if surroundStreamFirst then
+            Debug("videoCanDirectPlay: first audio stream is unsupported 5.1")
+            return false
         end if
 
         if stereoCodec <> invalid AND (stereoCodec = "aac" OR stereoCodec = "mp3") then
diff --git Plex/source/VideoSpringboardScreen.brs Plex/source/VideoSpringboardScreen.brs
index e704d87..b260c94 100644
--- Plex/source/VideoSpringboardScreen.brs
+++ Plex/source/VideoSpringboardScreen.brs
@@ -38,25 +38,33 @@ Sub videoSetupButtons()
     Debug("Media = " + tostr(m.media))
     Debug("Can direct play = " + tostr(videoCanDirectPlay(m.media)))
 
+    ' Trailers! (TODO) enable this for TV shows ( youtube is still useful )
+    ' if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
+    isTrailers = RegRead("trailers", "preferences")
+    if m.metadata.ContentType = "movie" AND  RegRead("trailers", "preferences", "disabled") <> "disabled" then 
+         m.AddButton("Trailer", "getTrailers")
+    end if
+
     supportedIdentifier = (m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.library" OR m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.myplex")
     if supportedIdentifier then
-        if m.metadata.viewCount <> invalid AND val(m.metadata.viewCount) > 0 then
+
+        ' Partial Watch ( can be watched/unwatched - but in progess) allow scrobbleMore dialog - to show both options mark as watched or unwatched
+        if m.metadata.viewOffset <> invalid AND val(m.metadata.viewOffset) > 0 then
+            m.AddButton("Mark as watched/unwatched", "scrobbleMore")
+        ' content is watched - show unscrobble button
+        else if m.metadata.viewCount <> invalid AND val(m.metadata.viewCount) > 0 then
             m.AddButton("Mark as unwatched", "unscrobble")
+        ' content is NOT watched - show unscrobble button
         else
-            if RegRead("rottentomatoes", "preferences", "disabled") = "disabled" then
-                if m.metadata.viewOffset <> invalid AND val(m.metadata.viewOffset) > 0 then
-                    m.AddButton("Mark as unwatched", "unscrobble")
-                end if
-            end if
             m.AddButton("Mark as watched", "scrobble")
         end if
-    end if
 
-    if m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.myplex" AND m.metadata.id <> invalid then
-        m.AddButton("Delete from queue", "delete")
     end if
 
-    m.AddButton("Playback options", "options")
+    ' Playback options only if a tvshow or episode -- movies use a line for trailers (moved this to more...)
+    if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
+      m.AddButton("Playback options", "options")
+    end if
 
     if supportedIdentifier then
         if m.metadata.UserRating = invalid then
@@ -84,15 +92,23 @@ Sub videoSetupButtons()
             m.AddButton(rating_string + " on Rotten Tomatoes", "tomatoes")
         endif
 
-        ' When delete is present we don't have enough room so we stuff delete
-        ' and rate in a separate dialog.
-        ' RR - when grandparentKey is present - we don't have enough room
-        ' either. We present 'Show All Seasons' and 'Show Season #'
-        if m.metadata.server.AllowsMediaDeletion OR m.metadata.grandparentKey <> invalid then
-            m.AddButton("More...", "more")
-        else
-            m.AddRatingButton(m.metadata.UserRating, m.metadata.StarRating, "rateVideo")
-        end if
+
+          if m.metadata.server.AllowsMediaDeletion AND m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.library" then
+              if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
+                  m.AddButton("Delete permanently","delete")
+              end if
+          end if
+
+	' more buttong if TV SHOW ( only if grandparent key is available,stops loops) OR if this is Movie
+	  if m.metadata.grandparentKey <> invalid or m.metadata.ContentType = "movie" then
+              m.AddButton("More...", "more")
+	  end if
+
+        ' Show rating bar if the content is a show or an episode - we might want this to be the delete button. We will see
+          if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
+               m.AddRatingButton(m.metadata.UserRating, m.metadata.StarRating, "rateVideo")
+	  end if
+
     end if
 End Sub
 
@@ -136,7 +152,11 @@ Function videoHandleMessage(msg) As Boolean
                 ' Refresh play data after unscrobbling
                 m.Refresh(true)
             else if buttonCommand = "delete" then
-                m.Item.server.Delete(m.metadata.id)
+	        key = m.metadata.id
+		if tostr(key) = "invalid"
+                  key = m.metadata.key
+                end if
+                m.Item.server.Delete(key)
                 m.Screen.Close()
             else if buttonCommand = "options" then
                 screen = createVideoOptionsScreen(m.metadata, m.ViewController, m.ContinuousPlay)
@@ -148,20 +168,74 @@ Function videoHandleMessage(msg) As Boolean
                 dialog.Title = ""
                 dialog.Text = ""
                 dialog.Item = m.metadata
-                dialog.SetButton("rate", "_rate_")
+
+                'if m.metadata.grandparentKey = invalid then
+                if m.metadata.ContentType = "movie"  then
+                    dialog.SetButton("options", "Playback options")
+                    dialog.SetButton("rate", "_rate_")
+                end if
 
                 ' display View All Seasons if we have grandparentKey -- entered from a episode
-                if m.metadata.grandparentKey <> invalid then
-                   dialog.SetButton("showFromEpisode", "View All Seasons")
+                if m.metadata.grandparentKey <> invalid then ' global on deck does not work with this
+                'if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
+                    dialog.SetButton("showFromEpisode", "View All Seasons")
                 end if
                 ' display View specific season if we have parentKey/parentIndex -- entered from a episode
-                if m.metadata.parentKey <> invalid AND m.metadata.parentIndex <> invalid then
+                if m.metadata.parentKey <> invalid AND m.metadata.parentIndex <> invalid then  ' global on deck does not work with this
+                'if m.metadata.ContentType = "show" or m.metadata.ContentType = "episode"  then
                    dialog.SetButton("seasonFromEpisode", "View Season " + m.metadata.parentIndex)
                 end if
 
+
+                ' Trailers link - RR (last now that we include it on the main screen .. well before delete - people my be used to delete being second to last)
+                'if m.metadata.grandparentKey = invalid then
+                if m.metadata.ContentType = "movie" AND  RegRead("trailers", "preferences", "disabled") <> "disabled" then 
+                    dialog.SetButton("getTrailers", "Trailer")
+                end if
+
+                supportedIdentifier = (m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.library" OR m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.myplex")
+                if supportedIdentifier then
+                    if m.metadata.viewCount <> invalid AND val(m.metadata.viewCount) > 0 then
+                        dialog.SetButton("unscrobble", "Mark as unwatched")
+                    else
+                        if m.metadata.viewOffset <> invalid AND val(m.metadata.viewOffset) > 0 then
+                            dialog.SetButton("unscrobble", "Mark as unwatched")
+                        end if
+                    end if
+                    dialog.SetButton("scrobble", "Mark as watched")
+                end if
+
                 if m.metadata.server.AllowsMediaDeletion AND m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.library" then
                     dialog.SetButton("delete", "Delete permanently")
                 end if
+
+                if m.metadata.ContentType = "episode" or m.metadata.ContentType = "show"  then
+                   ' dialog.SetButton("options", "Playback options")
+                    dialog.SetButton("rate", "_rate_")
+                end if
+
+                dialog.SetButton("close", "Back")
+                dialog.HandleButton = videoDialogHandleButton
+                dialog.ParentScreen = m
+                dialog.Show()
+            else if buttonCommand = "scrobbleMore" then
+                dialog = createBaseDialog()
+                dialog.Title = ""
+                dialog.Text = ""
+                dialog.Item = m.metadata
+
+                supportedIdentifier = (m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.library" OR m.metadata.mediaContainerIdentifier = "com.plexapp.plugins.myplex")
+                if supportedIdentifier then
+                    if m.metadata.viewCount <> invalid AND val(m.metadata.viewCount) > 0 then
+                        dialog.SetButton("unscrobble", "Mark as unwatched")
+                    else
+                        if m.metadata.viewOffset <> invalid AND val(m.metadata.viewOffset) > 0 then
+                            dialog.SetButton("unscrobble", "Mark as unwatched")
+                        end if
+                    end if
+                    dialog.SetButton("scrobble", "Mark as watched")
+                end if
+
                 dialog.SetButton("close", "Back")
                 dialog.HandleButton = videoDialogHandleButton
                 dialog.ParentScreen = m
@@ -170,6 +244,14 @@ Function videoHandleMessage(msg) As Boolean
                 rateValue% = msg.getData() /10
                 m.metadata.UserRating = msg.getdata()
                 m.Item.server.Rate(m.metadata.ratingKey, m.metadata.mediaContainerIdentifier,rateValue%.ToStr())
+            else if buttonCommand = "getTrailers" then
+                if m.metaData.OrigReleaseDate <> invalid then
+                     year = m.metaData.OrigReleaseDate
+                else 
+                     year = m.metaData.ReleaseDate
+                end if
+                youtube_search(tostr(m.metadata.CleanTitle),tostr(year))
+                'closeDialog = true
             else if buttonCommand = "tomatoes" then
                 dialog = createBaseDialog()
                 dialog.Title = "Rotten Tomatoes Review"
@@ -182,7 +264,8 @@ Function videoHandleMessage(msg) As Boolean
                      end if
 		end if
 
-		dialog.Text = review_text		
+		dialog.Text = review_text
+                dialog.SetButton("getTrailers", "Trailer")
                 dialog.SetButton("close", "Back")
                 dialog.HandleButton = videoDialogHandleButton
                 dialog.ParentScreen = m
@@ -199,6 +282,7 @@ End Function
 Function videoDialogHandleButton(command, data) As Boolean
     ' We're evaluated in the context of the dialog, but we want to be in
     ' the context of the original screen.
+    ' These are button presses from a Dialog - ljunkie
     obj = m.ParentScreen
 
     closeDialog = false
@@ -214,6 +298,23 @@ Function videoDialogHandleButton(command, data) As Boolean
         dummyItem.server = obj.metadata.server
         obj.ViewController.CreateScreenForItem(dummyItem, invalid, ["Series"])
         closeDialog = true
+    else if command = "getTrailers" then
+        youtube_search(tostr(obj.metadata.CleanTitle + " trailer",obj.metadata.Year))
+        closeDialog = true
+    else if command = "scrobble" then
+        obj.metadata.server.Scrobble(obj.metadata.ratingKey, obj.metadata.mediaContainerIdentifier)
+        obj.Refresh(true)
+        closeDialog = true
+    else if command = "unscrobble" then
+        obj.metadata.server.Unscrobble(obj.metadata.ratingKey, obj.metadata.mediaContainerIdentifier)
+        obj.Refresh(true)
+        closeDialog = true
+    else if Command = "options" then
+        screen = createVideoOptionsScreen(obj.metadata, obj.ViewController, obj.ContinuousPlay)
+        obj.ViewController.InitializeOtherScreen(screen, ["Video Playback Options"])
+        screen.Show()
+        obj.checkChangesOnActivate = true
+        closeDialog = true
     else if command = "seasonFromEpisode" then
         dummyItem = CreateObject("roAssociativeArray")
         dummyItem.ContentType = "series"
diff --git Plex/source/ViewController.brs Plex/source/ViewController.brs
index 87ad3da..8a80d41 100644
--- Plex/source/ViewController.brs
+++ Plex/source/ViewController.brs
@@ -102,7 +102,7 @@ Function vcCreateHomeScreen()
     screen.ScreenName = "Home"
     m.InitializeOtherScreen(screen, invalid)
     screen.Show()
-
+    RRbreadcrumbDate(screen) 'ljunkie - homescreen data/time
     return screen
 End Function
 
@@ -300,6 +300,9 @@ Function vcCreateVideoPlayer(metadata, seekValue=0, directPlayOptions=0, show=tr
     ' Stop any background audio first
     m.AudioPlayer.Stop()
 
+    ' Make sure we have full details before trying to play.
+    metadata.ParseDetails()
+
     ' Prompt about resuming if there's an offset and the caller didn't specify a seek value.
     if seekValue = invalid then
         if metadata.viewOffset <> invalid then
@@ -359,13 +362,13 @@ Sub vcShowReleaseNotes()
     header = GetGlobal("appName") + " has been updated to " + GetGlobal("appVersionStr")
     paragraphs = []
     paragraphs.Push("Changes in this version include:")
-    paragraphs.Push(" - Audio Preference updates: 5.1 and DTS settings")
-    paragraphs.Push(" - Rotten Tomatoes defaults to User Ratings + more HUD Updates")
+    paragraphs.Push(" - Trailer Support for Movies: Initial release")
     paragraphs.Push(" -- Custom changes made --")
+    paragraphs.Push(" - Audio Preference updates: 5.1 and DTS settings")
     paragraphs.Push(" - Rotten Tomatoes Critic/User Ratings (Enable in Preferences).")
     paragraphs.Push(" - Enter Season or Specific Season from Episode (More... button)")
-    paragraphs.Push(" - Release Date added to HUD (down button during video play)")
-    paragraphs.Push(" - Direct/Transcoded added to HUD (down button during video play)")
+    paragraphs.Push(" - Release Date info on HUD (down button during video play)")
+    paragraphs.Push(" - Direct/Transcoded info on HUD (down button during video play)")
     paragraphs.Push(" Enjoy. -Rob")
 
     screen = createParagraphScreen(header, paragraphs, m)
@@ -478,6 +481,7 @@ Sub vcPopScreen(screen)
         Debug("Top of stack is once again: " + screenName)
         m.Analytics.TrackScreen(screenName)
         newScreen.Activate(screen)
+        RRbreadcrumbDate(newScreen)
     end if
 
     ' If some other screen requested this close, let it know.
@@ -508,9 +512,31 @@ Sub vcShow()
     Debug("Starting global message loop")
 
     timeout = 0
+    lastmin = -1 'container to update every minute
     while m.screens.Count() > 0
         m.WebServer.prewait()
         msg = wait(timeout, m.GlobalMessagePort)
+
+        'ljunkie - minute refresh check - if minuteRefresh <> invalid, then it a brand spanking new minute
+        minuteRefresh = invalid
+        if lastmin <> invalid then 
+            date = CreateObject("roDateTime")
+            newmin = date.GetMinutes()
+            if newmin <> lastmin then 
+                'Debug(tostr(newmin) + " >  " + tostr(lastmin) + " minuteRefresh set")
+                minuteRefresh = 1
+                lastmin = date.GetMinutes()
+            end if
+        end if
+        ' end minute check
+
+        ' ljunkie - update clock on home screen (every minute) - only on roSocketEvent
+        if m.screens.Count() = 1 and type(msg) = "roSocketEvent" then 
+            if minuteRefresh <> invalid then
+                RRbreadcrumbDate(m.screens[0])
+            end if
+        end if
+
         if msg <> invalid then
             ' Printing debug information about every message may be overkill
             ' regardless, but note that URL events don't play by the same rules,
@@ -628,6 +654,8 @@ Sub vcUpdateScreenProperties(screen)
         AddAccountHeaders(screen.Screen, screen.Item.server.AccessToken)
     end if
 
+    ' ljunkie - current time -- removed from this - ONLY on home screen for now.
+
     if screen.NumBreadcrumbs <> 0 then
         count = m.breadcrumbs.Count()
         if count >= 2 then
@@ -647,6 +675,7 @@ Sub vcUpdateScreenProperties(screen)
 
     screenType = type(screen.Screen)
     ' Sigh, different screen types don't support breadcrumbs with the same functions
+
     if screenType = "roGridScreen" OR screenType = "roPosterScreen" OR screenType = "roSpringboardScreen" then
         if enableBreadcrumbs then
             screen.Screen.SetBreadcrumbEnabled(true)
diff --git Plex/source/appMain.brs Plex/source/appMain.brs
index 7c4bedc..f8af77d 100644
--- Plex/source/appMain.brs
+++ Plex/source/appMain.brs
@@ -45,6 +45,10 @@ Sub Main(args)
 
     initGlobals()
 
+    ' Youtube Trailers - RR
+    m.youtube = InitYouTube()
+    youtube = LoadYouTube()
+
     'prepare the screen for display and get ready to begin
     controller = createViewController()
     controller.Show()
diff --git Plex/source/rarflix.brs Plex/source/rarflix.brs
new file mode 100644
index 0000000..3a374d0
--- /dev/null
+++ Plex/source/rarflix.brs
@@ -0,0 +1,91 @@
+' other functions required for my mods
+Function GetDurationString( TotalSeconds = 0 As Integer, emptyHr = 0 As Integer, emptyMin = 0 As Integer, emptySec = 0 As Integer  ) As String
+   datetime = CreateObject( "roDateTime" )
+   datetime.FromSeconds( TotalSeconds )
+      
+   hours = datetime.GetHours().ToStr()
+   minutes = datetime.GetMinutes().ToStr()
+   seconds = datetime.GetSeconds().ToStr()
+   
+   duration = ""
+   If hours <> "0" or emptyHr = 1 Then
+      duration = duration + hours + "h "
+   End If
+
+   If minutes <> "0" or emptyMin = 1 Then
+      duration = duration + minutes + "m "
+   End If
+   If seconds <> "0" or emptySec = 1 Then
+      duration = duration + seconds + "s"
+   End If
+   
+   Return duration
+End Function
+
+
+Function RRmktime( epoch As Integer, localize = 1 as Integer) As String
+    datetime = CreateObject("roDateTime")
+    datetime.FromSeconds(epoch)
+    if localize = 1 then 
+        datetime.ToLocalTime()
+    end if
+    hours = datetime.GetHours()
+    minutes = datetime.GetMinutes()
+    seconds = datetime.GetSeconds()
+       
+    duration = ""
+    hour = hours
+    If hours = 0 Then
+       hour = 12
+    End If
+
+    If hours > 12 Then
+        hour = hours-12
+    End If
+
+    If hours >= 0 and hours < 12 Then
+        AMPM = "am"
+    else
+        AMPM = "pm"
+    End if
+       
+    minute = minutes.ToStr()
+    If minutes < 10 Then
+      minute = "0" + minutes.ToStr()
+    end if
+
+    result = hour.ToStr() + ":" + minute + AMPM
+
+    Return result
+End Function
+
+Function RRbitrate( bitrate As Float) As String
+    speed = bitrate/1000/1000
+    ' brightscript doesn't have sprintf ( only include on decimal place )
+    speed = speed * 10
+    speed = speed + 0.5
+    speed = fix(speed)
+    speed = speed / 10
+    format = "mbps"
+    if speed < 1 then
+      speed = speed*1000
+      format = "kbps"
+    end if
+    return tostr(speed) + format
+End Function
+
+Function RRbreadcrumbDate(myscreen) As Object
+    screenName = firstOf(myScreen.ScreenName, type(myScreen.Screen))
+    if screenName <> invalid and screenName = "Home" then 
+        Debug("update " + screenName + " screen time")
+        date = CreateObject("roDateTime")
+        date.ToLocalTime() ' localizetime
+        timeString = RRmktime(date.AsSeconds(),0)
+        dateString = date.AsDateString("short-month-short-weekday")
+        myscreen.Screen.SetBreadcrumbEnabled(true)
+        myscreen.Screen.SetBreadcrumbText(dateString, timeString)
+    else 
+        Debug("will NOT update " + screenName + " screen time. " + screenName +"=Home")
+    end if
+
+End function
diff --git Plex/source/rottenTomatoes.brs Plex/source/rottenTomatoes.brs
index 7368fdb..69ccd5e 100644
--- Plex/source/rottenTomatoes.brs
+++ Plex/source/rottenTomatoes.brs
@@ -14,18 +14,20 @@ Function getRottenTomatoesData(movieTitle)
     ' to determine which movie result matches the best.
     data = data.Trim() 
     json = ParseJSON(data)
-    movie = json.movies[0]
-    if movie <> invalid AND movie.ratings <> invalid AND movie.ratings.critics_score <> invalid then
-        ' ParseJSON does not handle negative numbers, so this ugly check needs to be performed on the JSON string.
-        ' Find the critics_score in the JSON string
-        score_pos = INSTR(0, data, Chr(34) + "critics_score" + Chr(34) +":")
-        if score_pos <> invalid then
-            ' If it is found, check the 2 characters after to see if they match the string "-1"
-            rating = MID(data, score_pos + 16, 2)
-            if rating = "-1" then
-                movie.ratings.critics_score = -1
+    if type(json) = "roAssociativeArray" then
+        movie = json.movies[0]
+        if movie <> invalid AND movie.ratings <> invalid AND movie.ratings.critics_score <> invalid then
+            ' ParseJSON does not handle negative numbers, so this ugly check needs to be performed on the JSON string.
+            ' Find the critics_score in the JSON string
+            score_pos = INSTR(0, data, Chr(34) + "critics_score" + Chr(34) +":")
+            if score_pos <> invalid then
+                ' If it is found, check the 2 characters after to see if they match the string "-1"
+                rating = MID(data, score_pos + 16, 2)
+                if rating = "-1" then
+                    movie.ratings.critics_score = -1
+                endif
             endif
+            return movie
         endif
-        return movie
     endif
 End Function
diff --git Plex/source/trailers.brs Plex/source/trailers.brs
new file mode 100644
index 0000000..4a5d5ed
--- /dev/null
+++ Plex/source/trailers.brs
@@ -0,0 +1,1023 @@
+Function LoadYouTube() As Object
+    return m.youtube
+End Function
+
+Function InitYouTube() As Object
+    ' enabled trailers by default 
+    trailersEnabled = RegRead("trailers", "preferences")
+    ' set if invalid or if the typo happened - we can take this out after a while
+    if trailersEnabled = invalid or trailersEnabled = "enabled_tmbd_ytfb" then
+        RegWrite("trailers", "enabled", "preferences")
+    end if
+
+
+    this = CreateObject("roAssociativeArray")
+    this.protocol = "http"
+    this.scope = this.protocol + "://gdata.youtube.com"
+    this.prefix = this.scope + "/feeds/api"
+
+    this.tmdb_scope = this.protocol + "://api.themoviedb.org"
+    this.tmdb_prefix = this.tmdb_scope + "/3"
+    this.tmdb_apikey = "cc34d5f77b86f8c21377b86d4420439a"
+
+    ' this.FieldsToInclude = "&fields=entry(title,author,link,gd:rating,media:group(media:category,media:description,media:thumbnail,yt:videoid))"
+    
+    this.CurrentPageTitle = ""
+    this.screen=invalid
+    this.video=invalid
+
+    'API Calls
+    this.ExecServerAPI = youtube_exec_api
+    this.ExecTmdbAPI = tmdb_exec_api
+    
+    'Search
+    this.SearchYouTube = youtube_search ' changed to a forced search
+
+    'Videos
+    this.DisplayVideoList = youtube_display_video_list
+    this.FetchVideoList = youtube_fetch_video_list
+    this.VideoDetails = youtube_display_video_springboard
+    this.newVideoListFromXML = youtube_new_video_list
+    this.newVideoFromXML = youtube_new_video
+
+
+    print "YouTube: init complete"
+    return this
+End Function
+
+Function youtube_exec_api(request As Dynamic) As Object
+
+    method = "GET"
+    url_stub = request
+    postdata = invalid
+    headers = { }
+
+    if type(request) = "roAssociativeArray" then
+        if request.url_stub<>invalid then url_stub = request.url_stub
+        if request.postdata<>invalid then : postdata = request.postdata : method="POST" : end if
+        if request.headers<>invalid then headers = request.headers
+        if request.method<>invalid then method = request.method
+    end if
+        
+    if Instr(0, url_stub, "http://") OR Instr(0, url_stub, "https://") then
+        http = NewHttp(url_stub)
+    else
+        http = NewHttp(m.prefix + "/" + url_stub)
+    end if
+'    http = NewHttp("http://www.rarforge.com")
+    Debug("url: " + tostr(m.prefix + "/" + url_stub))
+    if not headers.DoesExist("GData-Version") then headers.AddReplace("GData-Version", "2") 
+
+    http.method = method
+    'print "----------------------------------"
+    if postdata<>invalid then
+        rsp=http.PostFromStringWithTimeout(postdata, 10, headers)
+        'print "postdata:",postdata
+    else
+        rsp=http.getToStringWithTimeout(10, headers)
+    end if
+
+    xml=ParseXML(rsp)
+    returnObj = CreateObject("roAssociativeArray")
+    returnObj.xml = xml
+    returnObj.status = 200
+    'returnObj.status = http.status -- plex http functions only return data/string - we will just set this to 200 for now
+    returnObj.error = handleYoutubeError(returnObj) ' kind of redundant, but maybe useful later
+    return returnObj
+End Function
+
+Function handleYoutubeError(rsp) As Dynamic
+    ' Is there a status code? If not, return a connection error.
+    if rsp.status=invalid then return ShowConnectionFailed()
+    ' Don't check for errors if the response code was a 2xx or 3xx number
+    if int(rsp.status/100)=2 or int(rsp.status/100)=3 return ""
+    if not isxmlelement(rsp.xml) return ShowErrorDialog("API return invalid. Try again later", "Bad response")
+    error=rsp.xml.GetNamedElements("error")[0]
+    if error=invalid then
+        ' we got an unformatted HTML response with the error in the title
+        error=rsp.xml.GetChildElements()[0].GetChildElements()[0].GetText()
+    else
+        error=error.GetNamedElements("internalReason")[0].GetText()
+    end if
+    ShowDialog1Button("Error", error, "OK", true)
+    return error
+End Function
+
+Sub youtube_search(keyword as string, year = "invalid" as string )
+    dialog = createBaseDialog()
+    dialog.Title = ""
+    dialog.Text = ""
+    dialog=ShowPleaseWait("Please wait","Searching TMDB & YouTube for " + Quote()+keyword+Quote())
+    origSearch_trailer = keyword + " trailer"
+    searchString_trailer = URLEncode(origSearch_trailer)
+    searchString = URLEncode(keyword)
+    ' xml=m.youtube.ExecServerAPI("videos?q=HJEsNjH3JT8")["xml"]
+    ' try the TMDB first.. then try youtube
+    ' we could speed this up if we know the TMDB ( does PMS know this? )
+
+    Videos=CreateObject("roList")
+
+    if year <> "invalid" then
+       re = CreateObject("roRegex", "-", "") ' only grab the year
+       year = re.split(year)[0]
+       s_tmdb = m.youtube.ExecTmdbAPI("search/movie?query="+searchString+"&page=1&include_adult=false&year=" + tostr(year))["json"]
+       if s_tmdb.results.count() = 0 then
+         Debug("---------------- no match found with year.. try again")
+         year = "invalid" ' invalidate year to try again without it
+       end if
+    end if
+    
+    ' try TMDB lookup without year
+    if year = "invalid" then
+       s_tmdb = m.youtube.ExecTmdbAPI("search/movie?query="+searchString+"&page=1&include_adult=false")["json"]
+    end if
+
+    ' locate trailers for video
+    if s_tmdb.results.count() > 0 and tostr(s_tmdb.results[0].id) <> "invalid"  then
+       s_tmdb = m.youtube.ExecTmdbAPI("movie/"+tostr(s_tmdb.results[0].id)+"/trailers?page=1")["json"]
+    end if
+
+'    printAA(s_tmdb)
+    if type (s_tmdb) = "roAssociativeArray" and type(s_tmdb.youtube) = "roArray"  then 
+       for each trailer in s_tmdb.youtube
+            Debug("Found YouTube Trailer from TMDB")
+            PrintAA(trailer)
+            re = CreateObject("roRegex", "&", "") ' seems some urls have &hd=1 .. maybe more to come
+	    source = re.split(trailer.Source)[0]
+
+            ' verify it's playable first
+            if video_check_embed(source) <> "invalid" then
+              xml=m.youtube.ExecServerAPI("videos/" + source)["xml"]
+              if isxmlelement(xml) then 
+                  ' single video will be retured.. call newVideoFromXML
+                  video=m.youtube.newVideoFromXML(xml, searchString, "TMDb", "themoviedb.org")
+                  Videos.Push(video)      
+               else 
+                   Debug("---------------------- Failed to get TMDB YouTube Trailer ")
+              end if
+             end if
+        end for
+    end if
+
+    ' join raw youtube videos - maybe make this a toggle? some may ONLY want TMDB
+    trailerTypes = RegRead("trailers", "preferences")
+    includeYouTubeRaw = 0
+    
+    if trailerTypes = "enabled"  then 
+         print "------------ Included raw youtube trailer search (trailers: enabled) ------------------ trailer:" + trailerTypes
+         includeYouTubeRaw = 1 ' include youtube trailers when 'enabled' is set -- grab everything
+    else if videos.Count() = 0 and trailerTypes = "enabled_tmdb_ytfb"  then 
+         print "------------ Included raw youtube trailer search (trailers: enabled_tmdb_ytfb and 0 TMDB found) ------------------ trailer:" + trailerTypes
+         includeYouTubeRaw = 1 ' include youtube trailers when youtube fallback is enabled and we didn't find any trailers on tmdb
+    else 
+         print "------------ skipping raw youtube trailer search (found trailers on TMDB) ------------------ trailer:" + trailerTypes
+    end if
+
+    ' so - should we include the raw yourube search?
+    if includeYouTubeRaw = 1 then
+        xml=m.youtube.ExecServerAPI("videos?q="+searchString_trailer+"&prettyprint=true&max-results=6&alt=atom&paid-content=false&v=2")["xml"]
+        if isxmlelement(xml) then
+            Videos =m.youtube.newVideoListFromXML(xml.entry,Videos,origSearch_trailer)
+        else 
+            xml = CreateObject("roXMLElement") ' just backwards compatibility
+        end if
+    end if
+    
+    if videos.Count() > 0 then
+        dialog.Close()
+        m.youtube.DisplayVideoList(videos, "Search Results for "+Chr(39)+keyword+Chr(39), xml.link, invalid)
+    else
+        dialog.Close():ShowErrorDialog("No videos match your search","Search results")
+    end if
+End Sub
+
+Sub DisplayVideo(content As Object)
+    p = CreateObject("roMessagePort")
+    video = CreateObject("roVideoScreen")
+    video.setMessagePort(p)
+    video.SetPositionNotificationPeriod(5)
+    content.releaseDate = "Played: " + GetDurationString(0,0,1,1) ' just to keep the format the same on initial start
+    'PrintAA(content)
+    video.SetContent(content)
+    video.show()
+    
+    while true
+        msg = wait(0, video.GetMessagePort())
+        if type(msg) = "roVideoScreenEvent"
+            if msg.isScreenClosed() then 
+                video.Close()
+                exit while
+            else if msg.isStreamStarted() then
+		'print "Video status: "; msg.GetIndex(); " " msg.GetInfo() 
+            else if msg.isPlaybackPosition() then
+                'print "Video GetIndex: "; msg.GetIndex()
+                if msg.GetIndex() > 0
+		    content.releaseDate = "Played: " + GetDurationString(msg.GetIndex(),0,1,1)
+                    video.SetContent(content)
+                end if
+	    else if msg.isStatusMessage()
+                'print "Video status: "; msg.GetIndex(); " " msg.GetData() 
+            else if msg.isRequestFailed()
+                print "play failed: "; msg.GetMessage()
+            else
+                print "Unknown event: "; msg.GetType(); " msg: "; msg.GetMessage()
+            end if
+        end if
+    end while
+End Sub
+
+Function parseVideoFormatsMap(videoInfo As String) As Object
+
+    ' print "-----------------------------------------------"
+    ' print videoInfo
+    ' print "-----------------------------------------------"
+
+    r = CreateObject("roRegex", "(?:|&"+CHR(34)+")url_encoded_fmt_stream_map=([^(&|\$)]+)", "")
+    videoFormatsMatches = r.Match(videoInfo)
+
+    if videoFormatsMatches[0]<>invalid then
+        videoFormats = videoFormatsMatches[1]
+    else
+        print "parseVideoFormatsMap: didn't find any video formats"
+        print "---------------------------------------------------"
+        print videoInfo
+        print "---------------------------------------------------"
+        return invalid
+    end if
+
+    sep1 = CreateObject("roRegex", "%2C", "")
+    sep2 = CreateObject("roRegex", "%26", "")
+    sep3 = CreateObject("roRegex", "%3D", "")
+
+    videoURL = CreateObject("roAssociativeArray")
+    videoFormatsGroup = sep1.Split(videoFormats)
+
+    for each videoFormat in videoFormatsGroup
+        videoFormatsElem = sep2.Split(videoFormat)
+        videoFormatsPair = CreateObject("roAssociativeArray")
+        for each elem in videoFormatsElem
+            pair = sep3.Split(elem)
+            if pair.Count() = 2 then
+                videoFormatsPair[pair[0]] = pair[1]
+            end if
+        end for
+
+        if videoFormatsPair["url"]<>invalid then 
+            r1=CreateObject("roRegex", "\\\/", ""):r2=CreateObject("roRegex", "\\u0026", "")
+            url=URLDecode(URLDecode(videoFormatsPair["url"]))
+            r1.ReplaceAll(url, "/"):r2.ReplaceAll(url, "&")
+        end if
+        if videoFormatsPair["itag"]<>invalid then
+            itag = videoFormatsPair["itag"]
+        end if
+        if videoFormatsPair["sig"]<>invalid then 
+            sig = videoFormatsPair["sig"]
+            url = url + "&signature=" + sig
+        end if
+
+        if Instr(0, LCase(url), "http") = 1 then 
+            videoURL[itag] = url
+        end if
+    end for
+
+    qualityOrder = ["18","22","37"]
+    bitrates = [768,2250,3750]
+    isHD = [false,true,true]
+    streamQualities = []
+
+    for i=0 to qualityOrder.Count()-1
+        qn = qualityOrder[i]
+        if videoURL[qn]<>invalid then
+            streamQualities.Push({url: videoURL[qn], bitrate: bitrates[i], quality: isHD[i], contentid: qn})
+        end if
+    end for
+
+    return streamQualities
+
+End Function
+
+Sub youtube_display_video_list(videos As Object, title As String, links=invalid, screen=invalid)
+    if screen=invalid then
+        screen=uitkPreShowPosterMenu("flat-episodic-16x9", title)
+        screen.showMessage("Loading...")
+    end if
+    m.CurrentPageTitle = title
+
+    if videos.Count() > 0 then
+        metadata=GetVideoMetaData(videos)
+
+        for each link in links
+            if link@rel = "next" then
+                metadata.Push({shortDescriptionLine1: "More Results", action: "next", pageURL: link@href, HDPosterUrl:"pkg:/images/icon_next_episode.jpg", SDPosterUrl:"pkg:/images/icon_next_episode.jpg"})
+            else if link@rel = "previous" then
+                metadata.Unshift({shortDescriptionLine1: "Back", action: "prev", pageURL: link@href, HDPosterUrl:"pkg:/images/icon_prev_episode.jpg", SDPosterUrl:"pkg:/images/icon_prev_episode.jpg"})
+            end if
+        end for
+
+        onselect = [1, metadata, m,
+            function(video, youtube, set_idx)
+                if video[set_idx]["action"]<>invalid then
+                    youtube.FetchVideoList(video[set_idx]["pageURL"], youtube.CurrentPageTitle)
+                else
+                    youtube.VideoDetails(video[set_idx], youtube.CurrentPageTitle)
+                end if
+            end function]
+        uitkDoPosterMenu(metadata, screen, onselect)
+    else
+        uitkDoMessage("No videos found.", screen)
+    end if
+End Sub
+
+Sub youtube_display_video_springboard(video As Object, breadcrumb As String)
+    p = CreateObject("roMessagePort")
+    screen = CreateObject("roSpringboardScreen")
+    screen.SetMessagePort(p)
+
+    m.screen=screen
+    m.video=video
+
+    screen.SetDescriptionStyle("movie")
+    screen.AllowNavLeft(true)
+    screen.AllowNavRight(true)
+    screen.SetPosterStyle("rounded-rect-16x9-generic")
+    screen.SetDisplayMode("zoom-to-fill")
+    screen.SetBreadcrumbText(breadcrumb, "Video")
+
+    buttons = CreateObject("roAssociativeArray")
+
+    streamQualities = video_get_qualities(video.id)
+    if streamQualities<>invalid
+        video.Streams = streamQualities
+        
+        if streamQualities.Peek()["contentid"].toInt() > 18
+	    Debug("is HD")
+            video.HDBranded = true
+            video.FullHD = false
+        else if streamQualities.Peek()["contentid"].toInt() = 37
+            video.HDBranded = true
+            video.FullHD = true
+	    Debug("is FULL HD")
+        end if
+
+        buttons["play"] = screen.AddButton(0, "Play")
+    end if
+
+    'video.ReleaseDate = video.shortdescriptionline1
+
+    screen.SetContent(video)
+    screen.Show()
+
+    while true
+        msg = wait(0, screen.GetMessagePort())
+        if type(msg) = "roSpringboardScreenEvent" then
+            if msg.isScreenClosed()
+                'print "Closing springboard screen"
+                exit while
+            else if msg.isButtonPressed()
+                print "Button pressed: "; msg.GetIndex(); " " msg.GetData()
+                if msg.GetIndex() = 0 then
+                    DisplayVideo(video)
+                endif
+            else
+                print "Unknown event: "; msg.GetType(); " msg: "; msg.GetMessage()
+            endif
+        end If
+    end while
+End Sub
+
+Function video_get_qualities(videoID as String) As Object
+    http = NewHttp("http://www.youtube.com/get_video_info?video_id="+videoID)
+    Debug("SteamQualities: http://www.youtube.com/get_video_info?video_id="+videoID)
+    rsp = http.getToStringWithTimeout(10)
+    if rsp<>invalid then
+
+        videoFormats = parseVideoFormatsMap(rsp)
+        if videoFormats<>invalid then
+            if videoFormats.Count()>0 then
+                return videoFormats
+            end if
+        else
+            'try again with full youtube page
+            dialog=ShowPleaseWait("Looking for compatible videos...", invalid)
+            http = NewHttp("http://www.youtube.com/watch?v="+videoID)
+            rsp = http.getToStringWithTimeout(30)
+            if rsp<>invalid then
+                videoFormats = parseVideoFormatsMap(rsp)
+                if videoFormats<>invalid then
+                    if videoFormats.Count()>0 then
+                        dialog.Close()
+                        return videoFormats
+                    end if
+                else
+                    dialog.Close()
+                    ShowErrorDialog("Could not find any playable formats. Please try another video...")
+                end if
+            end if
+            dialog.Close()
+        end if
+
+    else
+        ShowErrorDialog("HTTP Request for get_video_info failed!")
+    end if
+    
+    return invalid
+End Function
+
+
+Function video_check_embed(videoID as String) As string
+    http = NewHttp("http://www.youtube.com/get_video_info?video_id="+videoID)
+    Debug("Checking Embed options: http://www.youtube.com/get_video_info?video_id="+videoID)
+    rsp = http.getToStringWithTimeout(10)
+    r = CreateObject("roRegex", "status=fail", "i")
+    if r.IsMatch(rsp) then
+          r = CreateObject("roRegex", "reason=([^(&|\$)]+)", "i")
+          if r.IsMatch(rsp) then
+            reason = r.Match(rsp)
+            Debug("-------" + videoID +"------------- this YouTube Video is not playable:" + URLDecode(tostr(reason[0])))
+          else 
+             r = CreateObject("roRegex", "Embedding\+disabled", "i")
+             if r.IsMatch(rsp) then
+               Debug("-------" + videoID +"------------- this YouTube Video is not playable -- embedding disabled")
+             end if
+           end if
+    else 
+        ' no failure - we can embed this
+        return "playable"
+    end if
+    
+    ' invalid for any result of status=fail
+    return "invalid"
+End Function
+
+Function URLEncode(str As String) As String
+    if not m.DoesExist("encodeProxyUrl") then m.encodeProxyUrl = CreateObject("roUrlTransfer")
+    return m.encodeProxyUrl.urlEncode(str)
+End Function
+
+Function URLDecode(str As String) As String
+    strReplace(str,"+"," ") ' backward compatibility
+    if not m.DoesExist("encodeProxyUrl") then m.encodeProxyUrl = CreateObject("roUrlTransfer")
+    return m.encodeProxyUrl.Unescape(str)
+End Function
+
+Function Quote()
+    q$ = Chr(34)
+    return q$
+End Function
+
+Function ShowPleaseWait(title As dynamic, text As dynamic) As Object
+    if not isstr(title) title = ""
+    if not isstr(text) text = ""
+
+    port = CreateObject("roMessagePort")
+    dialog = invalid
+
+    'the OneLineDialog renders a single line of text better
+    'than the MessageDialog.
+
+    if text = ""
+        dialog = CreateObject("roOneLineDialog")
+    else
+        dialog = CreateObject("roMessageDialog")
+        dialog.SetText(text)
+    endif
+
+    dialog.SetMessagePort(port)
+
+    dialog.SetTitle(title)
+    dialog.ShowBusyAnimation()
+    dialog.Show()
+    return dialog
+End Function
+
+Sub youtube_fetch_video_list(APIRequest As Dynamic, title As String)
+    
+    ' fields = m.FieldsToInclude
+    ' if Instr(0, APIRequest, "?") = 0 then
+    '     fields = "?"+Mid(fields, 2)
+    ' end if
+
+    screen=uitkPreShowPosterMenu("flat-episodic-16x9", title)
+    screen.showMessage("Loading...")
+
+    xml=m.ExecServerAPI(APIRequest)["xml"]
+    if not isxmlelement(xml) then ShowConnectionFailed():return
+    
+    videos=m.newVideoListFromXML(xml.entry)
+    m.DisplayVideoList(videos, title, xml.link, screen)
+
+End Sub
+
+Function youtube_new_video_list(xmllist As Object, videolist = invalid as Object, searchString = "invalid" as String) As Object
+    print "youtube_new_video_list init"
+
+    if videolist = invalid then
+        videolist=CreateObject("roList")
+    end if
+
+    for each record in xmllist
+           'ljunkie - might be slower -- but at least all the videos will play instead of having random videos that fail
+            source = record.GetNamedElements("media:group")[0].GetNamedElements("yt:videoid")[0].GetText()
+            if video_check_embed(source) <> "invalid" then
+             video=m.newVideoFromXML(record, SearchString)
+             videolist.Push(video)
+            end if
+    next
+    return videolist
+End Function
+
+Function youtube_new_video(xml As Object, searchString = "invalid" as String, provider = "YouTube" as String, providerLong = "YouTube" as String) As Object
+    video = CreateObject("roAssociativeArray")
+
+
+
+    video.youtube=m
+    video.xml=xml
+    video.GetID=function():return m.xml.GetNamedElements("media:group")[0].GetNamedElements("yt:videoid")[0].GetText():end function
+    video.GetAuthor=get_xml_author
+    video.GetUserID=function():return m.xml.GetNamedElements("media:group")[0].GetNamedElements("yt:uploaderId")[0].GetText():end function
+    video.GetTitle=function():return m.xml.title[0].GetText():end function
+    video.GetCategory=function():return m.xml.GetNamedElements("media:group")[0].GetNamedElements("media:category")[0].GetText():end function
+    video.GetDesc=function():return Left(m.xml.GetNamedElements("media:group")[0].GetNamedElements("media:description")[0].GetText(), 300):end function
+    video.GetRating=get_xml_rating
+    video.GetThumb=get_xml_thumb
+    video.GetEditLink=get_xml_edit_link
+    video.GetEditLink=get_xml_edit_link
+    'video.GetLinks=function():return m.xml.GetNamedElements("link"):end function
+    'video.GetURL=video_get_url
+    video.Provider=provider
+    video.ProviderLong=providerLong
+    video.SearchString=searchString
+    return video
+End Function
+
+Function GetVideoMetaData(videos As Object)
+    metadata=[]
+        
+    for each video in videos
+        meta=CreateObject("roAssociativeArray")
+        meta.ContentType="movie"
+        
+        meta.ID=video.GetID()
+        meta.provider=video.Provider
+        meta.providerLong=video.ProviderLong
+        meta.Author=video.GetAuthor()
+        meta.Title=video.GetTitle()
+        meta.Actors=meta.Author
+        meta.Description=video.GetDesc()
+        meta.Categories=video.GetCategory()
+        meta.StarRating=video.GetRating()
+        meta.ShortDescriptionLine1=meta.Title
+        meta.SDPosterUrl=video.GetThumb()
+        meta.HDPosterUrl=video.GetThumb()
+
+
+        ' cleanup Description
+        output = meta.Description
+        re = CreateObject("roRegex", "\s+", "i")
+        output = re.ReplaceAll(output, ". ")
+	if tostr(meta.provider) <> "YouTube" then
+           meta.Description = "Provided by: " + meta.providerLong + chr(10) + output
+	else 
+           meta.Description = "Provided by: YouTube search for '" + tostr(video.SearchString) +"'" + chr(10) + output
+        end if
+        meta.ShortDescriptionLine1 = meta.ShortDescriptionLine1 + " [" + meta.provider + "]"
+
+        meta.xml=video.xml
+        meta.UserID=video.GetUserID()
+        meta.EditLink=video.GetEditLink(video.xml)
+
+        meta.StreamFormat="mp4"
+        meta.Streams=[]
+        'meta.StreamBitrates=[]
+        'meta.StreamQualities=[]
+        'meta.StreamUrls=[]
+        
+        metadata.Push(meta)
+    end for
+    
+    return metadata
+End Function
+
+Function get_xml_author() As Dynamic
+    credits=m.xml.GetNamedElements("media:group")[0].GetNamedElements("media:credit")
+    if credits.Count()>0 then
+        for each author in credits
+            if author.GetAttributes()["role"] = "uploader" then return author.GetAttributes()["yt:display"]
+        end for
+    end if
+End Function
+
+Function get_xml_rating() As Dynamic
+    if m.xml.GetNamedElements("gd:rating").Count()>0 then
+        return m.xml.GetNamedElements("gd:rating").GetAttributes()["average"].toInt()*20
+    end if
+    return invalid
+End Function
+
+Function get_xml_edit_link(xml) As Dynamic
+    links=xml.GetNamedElements("link")
+    if links.Count()>0 then
+        for each link in links
+            'print link.GetAttributes()["rel"]
+            if link.GetAttributes()["rel"] = "edit" then return link.GetAttributes()["href"]
+        end for
+    end if
+    return invalid
+End Function
+
+Function get_xml_thumb() As Dynamic
+    thumbs=m.xml.GetNamedElements("media:group")[0].GetNamedElements("media:thumbnail")
+    if thumbs.Count()>0 then
+        for each thumb in thumbs
+            if thumb.GetAttributes()["yt:name"] = "mqdefault" then return thumb.GetAttributes()["url"]
+        end for
+        return m.xml.GetNamedElements("media:group")[0].GetNamedElements("media:thumbnail")[0].GetAttributes()["url"]
+    end if
+    return "pkg:/images/icon_s.jpg"
+End Function
+
+Function ParseXML(str As String) As dynamic
+    if str = invalid return invalid
+    xml=CreateObject("roXMLElement")
+    if not xml.Parse(str) return invalid
+    return xml
+End Function
+
+Sub ShowConnectionFailed()
+    Dbg("Connection Failed")
+    title = "Can't connect to service"
+    text  = GetConnectionFailedText()
+    ShowErrorDialog(text, title)
+End Sub
+
+Sub Dbg(pre As Dynamic, o=invalid As Dynamic)
+    p = AnyToString(pre)
+    if p = invalid p = ""
+    if o = invalid o = ""
+    s = AnyToString(o)
+    if s = invalid s = "???: " + type(o)
+    if Len(s) > 4000
+        s = Left(s, 4000)
+    endif
+    print p + s
+End Sub
+
+Function GetConnectionFailedText() as String
+    return "We were unable to connect to the service.  Please try again in a few minutes."
+End Function
+
+Function ShowConnectionFailedRetry() as dynamic
+    Dbg("Connection Failed Retry")
+    title = "Can't connect to service"
+    text  = GetConnectionFailedText()
+    return ShowDialog2Buttons(title, text, "Try Again", "Back")
+End Function
+
+Sub ShowErrorDialog(text As dynamic, title=invalid as dynamic)
+    if not isstr(text) text = "Unspecified error"
+    if not isstr(title) title = "Error"
+    ShowDialog1Button(title, text, "Done")
+End Sub
+
+Sub ShowDialog1Button(title As dynamic, text As dynamic, but1 As String, quickReturn=false As Boolean)
+    if not isstr(title) title = ""
+    if not isstr(text) text = ""
+
+    Dbg("DIALOG1: ", title + " - " + text)
+
+    port = CreateObject("roMessagePort")
+    dialog = CreateObject("roMessageDialog")
+    dialog.SetMessagePort(port)
+
+    dialog.SetTitle(title)
+    dialog.SetText(text)
+    dialog.AddButton(0, but1)
+    dialog.Show()
+
+    if quickReturn=true then return
+
+    while true
+        dlgMsg = wait(0, dialog.GetMessagePort())
+
+        if type(dlgMsg) = "roMessageDialogEvent"
+            if dlgMsg.isScreenClosed()
+                'print "Screen closed"
+                return
+            else if dlgMsg.isButtonPressed()
+                print "Button pressed: "; dlgMsg.GetIndex(); " " dlgMsg.GetData()
+                return
+            endif
+        endif
+    end while
+End Sub
+
+
+Function ShowDialog2Buttons(title As dynamic, text As dynamic, but1 As String, but2 As String) As Integer
+    if not isstr(title) title = ""
+    if not isstr(text) text = ""
+
+    Dbg("DIALOG2: ", title + " - " + text)
+
+    port = CreateObject("roMessagePort")
+    dialog = CreateObject("roMessageDialog")
+    dialog.SetMessagePort(port)
+
+    dialog.SetTitle(title)
+    dialog.SetText(text)
+    dialog.AddButton(0, but1)
+    dialog.AddButton(1, but2)
+    dialog.Show()
+
+    while true
+        dlgMsg = wait(0, dialog.GetMessagePort())
+
+        if type(dlgMsg) = "roMessageDialogEvent"
+            if dlgMsg.isScreenClosed()
+                'print "Screen closed"
+                dialog = invalid
+                return 0
+            else if dlgMsg.isButtonPressed()
+                print "Button pressed: "; dlgMsg.GetIndex(); " " dlgMsg.GetData()
+                dialog = invalid
+                return dlgMsg.GetIndex()
+            endif
+        endif
+    end while
+End Function
+
+Function isxmlelement(obj as dynamic) As Boolean
+    if obj = invalid return false
+    if GetInterface(obj, "ifXMLElement") = invalid return false
+    return true
+End Function
+
+' uitk Poster/Grids -- remove these and use Plex functions (TODO)
+Function uitkPreShowPosterMenu(ListStyle="flat-category" as String, breadA=invalid, breadB=invalid) As Object
+	port=CreateObject("roMessagePort")
+	screen = CreateObject("roPosterScreen")
+	screen.SetMessagePort(port)
+
+	if breadA<>invalid and breadB<>invalid then
+		screen.SetBreadcrumbText(breadA, breadB)
+        else if breadA<>invalid and breadB = invalid then
+        screen.SetTitle(breadA)
+	end if
+
+    if ListStyle = "" OR ListStyle = invalid then
+        ListStyle = "flat-category"
+    end if
+
+	screen.SetListStyle(ListStyle)
+	screen.SetListDisplayMode("scale-to-fit")
+	 screen.SetListDisplayMode("zoom-to-fill")
+	screen.Show()
+
+	return screen
+end function
+
+Function uitkDoPosterMenu(posterdata, screen, onselect_callback=invalid) As Integer
+
+	if type(screen)<>"roPosterScreen" then
+		print "illegal type/value for screen passed to uitkDoPosterMenu()" 
+		return -1
+	end if
+	
+	screen.SetContentList(posterdata)
+
+    while true
+        msg = wait(0, screen.GetMessagePort())
+		
+		'print "uitkDoPosterMenu | msg type = ";type(msg)
+		
+		if type(msg) = "roPosterScreenEvent" then
+			print "event.GetType()=";msg.GetType(); " event.GetMessage()= "; msg.GetMessage()
+			if msg.isListItemSelected() then
+				if onselect_callback<>invalid then
+					selecttype = onselect_callback[0]
+					if selecttype=0 then
+						this = onselect_callback[1]
+                        selected_callback=onselect_callback[msg.GetIndex()+2]
+                        if islist(selected_callback) then
+                            f=selected_callback[0]
+                            userdata1=selected_callback[1]
+                            userdata2=selected_callback[2]
+                            userdata3=selected_callback[3]
+                            
+                            if userdata1=invalid then
+                                this[f]()
+                            else if userdata2=invalid then
+                                this[f](userdata1)
+                            else if userdata3=invalid then
+                                this[f](userdata1, userdata2)
+                            else
+                                this[f](userdata1, userdata2, userdata3)
+                            end if
+                        else
+                            if selected_callback="return" then
+                                return msg.GetIndex()
+                            else
+                                this[selected_callback]()
+                            end if
+                        end if
+					else if selecttype=1 then
+						userdata1=onselect_callback[1]
+						userdata2=onselect_callback[2]
+						f=onselect_callback[3]
+						f(userdata1, userdata2, msg.GetIndex())
+					end if
+				else
+					return msg.GetIndex()
+				end if
+			else if msg.isScreenClosed() then
+				return -1
+			end if
+        end if
+	end while
+End Function
+
+Function uitkPreShowListMenu(breadA=invalid, breadB=invalid) As Object
+    port=CreateObject("roMessagePort")
+    screen = CreateObject("roListScreen")
+    screen.SetMessagePort(port)
+    if breadA<>invalid and breadB<>invalid then
+        screen.SetBreadcrumbText(breadA, breadB)
+    end if
+    'screen.SetListStyle("flat-category")
+    'screen.SetListDisplayMode("best-fit")
+    'screen.SetListDisplayMode("zoom-to-fill")
+    screen.Show()
+
+    return screen
+end function
+
+Function uitkDoListMenu(posterdata, screen, onselect_callback=invalid) As Integer
+
+    if type(screen)<>"roListScreen" then
+        print "illegal type/value for screen passed to uitkDoListMenu()" 
+        return -1
+    end if
+    
+    screen.SetContent(posterdata)
+
+    while true
+        msg = wait(0, screen.GetMessagePort())
+        
+        'print "uitkDoPosterMenu | msg type = ";type(msg)
+        
+        if type(msg) = "roListScreenEvent" then
+            print "event.GetType()=";msg.GetType(); " Event.GetMessage()= "; msg.GetMessage()
+            if msg.isListItemSelected() then
+                if onselect_callback<>invalid then
+                    selecttype = onselect_callback[0]
+                    if selecttype=0 then
+                        this = onselect_callback[1]
+                        selected_callback=onselect_callback[msg.GetIndex()+2]
+                        if islist(selected_callback) then
+                            f=selected_callback[0]
+                            userdata1=selected_callback[1]
+                            userdata2=selected_callback[2]
+                            userdata3=selected_callback[3]
+                            
+                            if userdata1=invalid then
+                                this[f]()
+                            else if userdata2=invalid then
+                                this[f](userdata1)
+                            else if userdata3=invalid then
+                                this[f](userdata1, userdata2)
+                            else
+                                this[f](userdata1, userdata2, userdata3)
+                            end if
+                        else
+                            if selected_callback="return" then
+                                return msg.GetIndex()
+                            else
+                                this[selected_callback]()
+                            end if
+                        end if
+                    else if selecttype=1 then
+                        userdata1=onselect_callback[1]
+                        userdata2=onselect_callback[2]
+                        f=onselect_callback[3]
+                        f(userdata1, userdata2, msg.GetIndex())
+                    end if
+                else
+                    return msg.GetIndex()
+                end if
+            else if msg.isScreenClosed() then
+                return -1
+            end if
+        end if
+    end while
+End Function
+
+Function uitkDoCategoryMenu(categoryList, screen, content_callback, onclick_callback) As Integer  
+    'Set current category to first in list
+    category_idx=0
+    
+    screen.SetListNames(categoryList)
+    contentdata1=content_callback[0]
+    contentdata2=content_callback[1]
+    content_f=content_callback[2]
+    
+    contentlist=content_f(contentdata1, contentdata2, 0)
+    
+    if contentlist.Count()=0 then
+        screen.SetContentList([])
+        screen.SetMessage("No viewable content in this section")
+    else
+        screen.SetContentList(contentlist)
+    end if
+    screen.Show()
+    
+    while true
+        msg = wait(0, screen.GetMessagePort())
+        if type(msg) = "roPosterScreenEvent" then
+            if msg.isListFocused() then
+                category_idx=msg.GetIndex()
+                contentdata1=content_callback[0]
+                contentdata2=content_callback[1]
+                content_f=content_callback[2]
+                
+                contentlist=content_f(contentdata1, contentdata2, category_idx)
+    
+                if contentlist.Count()=0 then
+                    screen.SetContentList([])
+                    screen.ShowMessage("No viewable content in this section")
+                else
+                    screen.SetContentList(contentlist)
+                    screen.SetFocusedListItem(0)
+                end if
+            else if msg.isListItemSelected() then
+                userdata1=onclick_callback[0]
+                userdata2=onclick_callback[1]
+                content_f=onclick_callback[2]
+                
+                content_f(userdata1, userdata2, category_idx, msg.GetIndex())
+            else if msg.isScreenClosed() then
+                return -1
+            end if
+        end If
+    end while
+End Function
+
+Sub uitkDoMessage(message, screen)
+    screen.showMessage(message)
+    while true
+        msg = wait(0, screen.GetMessagePort())
+        if msg.isScreenClosed() then
+            return
+        end if
+    end while
+End Sub
+' end uitk
+
+
+
+
+
+Function tmdb_exec_api(request As Dynamic) As Object
+
+    method = "GET"
+    url_stub = request
+    postdata = invalid
+    headers = { }
+
+    if type(request) = "roAssociativeArray" then
+        if request.url_stub<>invalid then url_stub = request.url_stub
+        if request.postdata<>invalid then : postdata = request.postdata : method="POST" : end if
+        if request.headers<>invalid then headers = request.headers
+        if request.method<>invalid then method = request.method
+    end if
+        
+    url_stub = url_stub + "&api_key=" + m.tmdb_apikey
+    if Instr(0, url_stub, "http://") OR Instr(0, url_stub, "https://") then
+        Debug("url: " + url_stub)
+        http = NewHttp(url_stub)
+    else
+        Debug("url: " + tostr(m.tmdb_prefix + "/" + url_stub))
+        http = NewHttp(m.tmdb_prefix + "/" + url_stub)
+
+    end if
+
+
+    if not headers.DoesExist("Accept") then headers.AddReplace("Accept", "application/json") 
+    'xhr.setRequestHeader("Accept", "application/json");
+    http.method = method
+    'print "----------------------------------"
+    if postdata<>invalid then
+        rsp=http.PostFromStringWithTimeout(postdata, 10, headers)
+        'print "postdata:",postdata
+    else
+        rsp=http.getToStringWithTimeout(10, headers)
+    end if
+
+    json=ParseJSON(rsp)
+    returnObj = CreateObject("roAssociativeArray")
+    returnObj.json = json
+    returnObj.status = 200
+    'returnObj.status = http.status -- plex http functions only return data/string - we will just set this to 200 for now
+    'returnObj.error = handleYoutubeError(returnObj) ' kind of redundant, but maybe useful later
+    return returnObj
+End Function
+
diff --git Plex/source/urlUtils.brs Plex/source/urlUtils.brs
index 617dc6e..89f99ff 100644
--- Plex/source/urlUtils.brs
+++ Plex/source/urlUtils.brs
@@ -122,9 +122,18 @@ REM Performs Http.AsyncGetToString() with a single timeout in seconds
 REM To the outside world this appears as a synchronous API.
 REM ******************************************************
 
-Function http_get_to_string_with_timeout(seconds as Integer) as String
+Function http_get_to_string_with_timeout(seconds as Integer, headers=invalid As Object) as String
+'Function http_get_to_string_with_timeout(seconds as Integer) as String
     timeout% = 1000 * seconds
 
+    ' added for trailer/youtube support - RR
+    if headers<>invalid then
+        for each key in headers
+            print key,headers[key]
+            m.Http.AddHeader(key, headers[key])
+        end for
+    end if
+
     str = ""
     m.Http.EnableFreshConnection(true) 'Don't reuse existing connections
     if (m.Http.AsyncGetToString())
diff --git README.md README.md
index ed50f60..09f0398 100644
--- README.md
+++ README.md
@@ -44,6 +44,12 @@ There are some additional targets in the Makefile, like `make rel install` to
 build a release, but you don't generally need them. One other nicety is the
 ability to take a screenshot using `make screenshot`.
 
+**Note:** Some Roku versions are beginning to require HTTP authentication for
+the installer. This is somewhat handled, but not necessarily robustly, so
+you may need to make some tweaks. You can set environment variables for
+`ROKU_DEV_USERNAME` and `ROKU_DEV_PASSWORD`, which default to `rokudev` and
+`plex` respectively.
+
 ### Debugging
 
 The Roku doesn't have logging per se, but dev channels are able to write
diff --git Release-Notes/2.6.8.en.txt Release-Notes/2.6.8.en.txt
new file mode 100644
index 0000000..0dd8fc1
--- /dev/null
+++ Release-Notes/2.6.8.en.txt
@@ -0,0 +1,8 @@
+NEW:
+  - Add transcode session info to the HUD.
+  - Add a toggle for DTS support.
+
+FIXES:
+  - Fix a crash in Playback Options for non-library content.
+  - Fix for Direct Playable content flung from iOS.
+  - Fix H.264 level preference.
diff --git master.20130906.patch master.20130906.patch
new file mode 100644
index 0000000..430f2c1
--- /dev/null
+++ master.20130906.patch
@@ -0,0 +1,374 @@
+diff --git Plex/source/KeyboardScreen.brs Plex/source/KeyboardScreen.brs
+index 787dce2..86c0177 100644
+--- Plex/source/KeyboardScreen.brs
++++ Plex/source/KeyboardScreen.brs
+@@ -50,7 +50,7 @@ Function kbHandleMessage(msg) As Boolean
+                     m.Text = m.Screen.GetText()
+                     if m.Listener <> invalid then
+                         m.Listener.OnUserInput(m.Text, m)
+-                    else
++                    else if m.Item <> invalid then
+                         callback = CreateObject("roAssociativeArray")
+                         callback.Heading = m.Text
+                         callback.Item = CreateObject("roAssociativeArray")
+diff --git Plex/source/PlexMediaServer.brs Plex/source/PlexMediaServer.brs
+index 7209f7a..35c25c4 100644
+--- Plex/source/PlexMediaServer.brs
++++ Plex/source/PlexMediaServer.brs
+@@ -576,9 +566,19 @@ Function TranscodingVideoUrl(videoUrl As String, item As Object, httpHeaders As
+     ' here.
+ 
+     ' The universal transcoder doesn't support old school XML with no Media
+-    ' elements, so check for that and use the old transcoder.
++    ' elements, so check for that and use the old transcoder. It also won't
++    ' work when analysis fails and there are no streams. The old transcoder
++    ' may not work with those files anyway, but the universal transcoder will
++    ' definitely fail.
+ 
+-    if item.preferredMediaItem <> invalid AND m.SupportsUniversalTranscoding AND RegRead("transcoder_version", "preferences", "universal") = "universal" then
++    hasStreams = false
++    if item.preferredMediaItem <> invalid then
++        if item.preferredMediaItem.preferredPart <> invalid then
++            hasStreams = (item.preferredMediaItem.preferredPart.streams.Count() > 0)
++        end if
++    end if
++
++    if hasStreams AND m.SupportsUniversalTranscoding AND RegRead("transcoder_version", "preferences", "universal") = "universal" then
+         return m.UniversalTranscodingVideoUrl(videoUrl, item, seekValue)
+     else
+         return m.ClassicTranscodingVideoUrl(videoUrl, item, httpHeaders)
+@@ -809,9 +809,7 @@ Function Capabilities(recompute=false) As String
+     ' signal through and theoretically doesn't care if it's 7.1.
+     if SupportsSurroundSound(true, true) then
+         fiveone = RegRead("fivepointone", "preferences", "1")
+-        fiveoneDCA = RegRead("fivepointoneDCA", "preferences", "1")
+         Debug("5.1 support set to: " + fiveone)
+-        Debug("5.1 DTS support set to: " + fiveoneDCA)
+ 
+         if fiveone <> "2" then
+             audio = audio + ",ac3{channels:8}"
+diff --git Plex/source/PreferenceScreen.brs Plex/source/PreferenceScreen.brs
+index 8535cc0..408bf73 100644
+--- Plex/source/PreferenceScreen.brs
++++ Plex/source/PreferenceScreen.brs
+@@ -591,7 +578,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
+         default: "40"
+     }
+ 
+-
+     ' HLS seconds per segment
+     lengths = [
+         { title: "Automatic", EnumValue: "auto", ShortDescriptionLine2: "Chooses based on quality." },
+@@ -604,7 +590,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
+         default: "10"
+     }
+ 
+-
+     ' Analytics (opt-out)
+     values = [
+         { title: "Enabled", EnumValue: "1" },
+@@ -625,7 +610,6 @@ Function createAdvancedPrefsScreen(viewController) As Object
+     obj.AddItem({title: "Continuous Play"}, "continuous_play", obj.GetEnumValue("continuous_play"))
+     obj.AddItem({title: "H.264"}, "level", obj.GetEnumValue("level"))
+ 
+-
+     if GetGlobal("legacy1080p") then
+         obj.AddItem({title: "1080p Settings"}, "1080p")
+     end if
+@@ -753,59 +737,55 @@ Function createAudioPrefsScreen(viewController) As Object
+         default: "loop"
+     }
+ 
+-    ' Audio boost for transcoded content. Transcoded content is quiet by
+-    ' default, but if we set a default boost then audio will never be remuxed.
+-    ' These values are based on iOS.
+-    ' moved into Audio Preferences - RR
+-    values = [
+-        { title: "None", EnumValue: "100" },
+-        { title: "Small", EnumValue: "175" },
+-        { title: "Large", EnumValue: "225" },
+-        { title: "Huge", EnumValue: "300" }
+-    ]
+-    obj.Prefs["audio_boost"] = {
+-        values: values,
+-        heading: "Audio boost for transcoded video",
+-        default: "100"
+-    }
+-
+-
+-    ' 5.1 Support
+-    ' moved into Audio Preferences - RR
++    ' 5.1 Support - AC-3
+     fiveone = [
+         { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to copy 5.1 audio streams when transcoding." },
+         { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Always use 2-channel audio when transcoding." }
+     ]
+     obj.Prefs["fivepointone"] = {
+         values: fiveone,
+-        heading: "5.1 audio support for transcoded content",
++        heading: "5.1 AC-3 support",
+         default: "1"
+     }
+ 
+-
+-    ' DTS support - Added by RR
+-    ' moved into Audio Preferences - RR
++    ' 5.1 Support - DTS
+     fiveoneDCA = [
+-        { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to copy DTS audio streams when transcoding." },
+-        { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Always use 2-channel audio when transcoding." }
++        { title: "Enabled", EnumValue: "1", ShortDescriptionLine2: "Try to Direct Play DTS in MKVs." },
++        { title: "Disabled", EnumValue: "2", ShortDescriptionLine2: "Never Direct Play DTS." }
+     ]
+     obj.Prefs["fivepointoneDCA"] = {
+         values: fiveoneDCA,
+-        heading: "DTS audio support for transcoded content",
++        heading: "5.1 DTS support",
+         default: "1"
+     }
+ 
++    ' Audio boost for transcoded content. Transcoded content is quiet by
++    ' default, but if we set a default boost then audio will never be remuxed.
++    ' These values are based on iOS.
++    values = [
++        { title: "None", EnumValue: "100" },
++        { title: "Small", EnumValue: "175" },
++        { title: "Large", EnumValue: "225" },
++        { title: "Huge", EnumValue: "300" }
++    ]
++    obj.Prefs["audio_boost"] = {
++        values: values,
++        heading: "Audio boost for transcoded video",
++        default: "100"
++    }
+ 
+     obj.Screen.SetHeader("Audio Preferences")
+ 
+     obj.AddItem({title: "Loop Playback"}, "loopalbums", obj.GetEnumValue("loopalbums"))
+     obj.AddItem({title: "Theme Music"}, "theme_music", obj.GetEnumValue("theme_music"))
+-    obj.AddItem({title: "Audio Boost"}, "audio_boost", obj.GetEnumValue("audio_boost"))
++
+     if SupportsSurroundSound(true) then
+-        obj.AddItem({title: "5.1 Support"}, "fivepointone", obj.GetEnumValue("fivepointone"))
++        obj.AddItem({title: "5.1 AC-3 Support"}, "fivepointone", obj.GetEnumValue("fivepointone"))
+         obj.AddItem({title: "5.1 DTS Support"}, "fivepointoneDCA", obj.GetEnumValue("fivepointoneDCA"))
+     end if
+ 
++    obj.AddItem({title: "Audio Boost"}, "audio_boost", obj.GetEnumValue("audio_boost"))
++
+     obj.AddItem({title: "Close"}, "close")
+ 
+     return obj
+@@ -821,12 +801,10 @@ Function prefsAudioHandleMessage(msg) As Boolean
+             m.ViewController.PopScreen(m)
+         else if msg.isListItemSelected() then
+             command = m.GetSelectedCommand(msg.GetIndex())
+-            ' Moved DTS, 5.1 and Audio Boost into audio Prefs RR
+-            ' OLD: if command = "loopalbums" OR command = "theme_music" then
+-            if command = "loopalbums" OR command = "theme_music" OR command = "fivepointone" OR command = "fivepointoneDCA" OR command = "audio_boost" then
+-                m.HandleEnumPreference(command, msg.GetIndex())
+-            else if command = "close" then
++            if command = "close" then
+                 m.Screen.Close()
++            else
++                m.HandleEnumPreference(command, msg.GetIndex())
+             end if
+         end if
+     end if
+--- Plex/source/VideoPlayer.brs
++++ Plex/source/VideoPlayer.brs
+@@ -193,8 +176,6 @@ Function videoPlayerCreateVideoPlayer()
+ 
+     videoPlayer.SetPositionNotificationPeriod(5)
+ 
+-
+-
+     m.IsTranscoded = videoItem.IsTranscoded
+     m.videoItem = videoItem
+     m.videoPlayer = videoPlayer
+@@ -522,6 +466,8 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+     end if
+     mediaItem.canDirectPlay = false
+     mediaItem.cachedSurroundSound = surroundSound
++    surroundSoundDCA = surroundSound AND (RegRead("fivepointoneDCA", "preferences", "1") = "1")
++    surroundSound = surroundSound AND (RegRead("fivepointone", "preferences", "1") = "1")
+ 
+     if mediaItem.preferredPart <> invalid AND mediaItem.preferredPart.subtitles <> invalid then
+         subtitleStream = mediaItem.preferredPart.subtitles
+@@ -584,15 +530,6 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+         next
+     end if
+ 
+-    ' ljunkie - for some reason fling video from iPhone to Roku skips code above let's set the surroundCodec to mediaItem.audioCodec if it's still invalid 
+-    ' TODO @ http://forums.plexapp.com/index.php/topic/79460-fling-direct-play-broken-from-iphone-dca-codec/
+-    ' This has been fixed in 2.6.8 a different way -- back out changes when I implement the 'correct' fix
+-    if surroundCodec = invalid then
+-           surroundCodec = mediaItem.audioCodec
+-    end if
+-    fiveoneDCA = RegRead("fivepointoneDCA", "preferences", "1")
+-    Debug("DTS support set to  " + fiveoneDCA)
+-
+     Debug("Media item optimized for streaming: " + tostr(mediaItem.optimized))
+     Debug("Media item container: " + tostr(mediaItem.container))
+     Debug("Media item video codec: " + tostr(mediaItem.videoCodec))
+@@ -652,16 +589,16 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+             return false
+         end if
+ 
+-        if surroundStreamFirst AND surroundCodec = "aac" then
+-            Debug("videoCanDirectPlay: first audio stream is 5.1 AAC")
+-            return false
+-        end if
+-
+         if surroundSound AND (surroundCodec = "ac3" OR stereoCodec = "ac3") then
+             mediaItem.canDirectPlay = true
+             return true
+         end if
+ 
++        if surroundStreamFirst then
++            Debug("videoCanDirectPlay: first audio stream is unsupported 5.1")
++            return false
++        end if
++
+         if stereoCodec = "aac" then
+             mediaItem.canDirectPlay = true
+             return true
+@@ -728,15 +665,19 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+             end if
+         end if
+ 
+-        if surroundSound then
+-            if (surroundCodec = "ac3" OR stereoCodec = "ac3") then
+-                mediaItem.canDirectPlay = true
+-                return true
+-            end if
+-            if (fiveoneDCA <> "2" AND surroundCodec = "dca") then
+-                mediaItem.canDirectPlay = true
+-                return true
+-            end if
++        if surroundSound AND (surroundCodec = "ac3" OR stereoCodec = "ac3") then
++            mediaItem.canDirectPlay = true
++            return true
++        end if
++
++        if surroundSoundDCA AND (surroundCodec = "dca" OR stereoCodec = "dca") then
++            mediaItem.canDirectPlay = true
++            return true
++        end if
++
++        if surroundStreamFirst then
++            Debug("videoCanDirectPlay: first audio stream is unsupported 5.1")
++            return false
+         end if
+ 
+         if stereoCodec <> invalid AND (stereoCodec = "aac" OR stereoCodec = "mp3") then
+@@ -744,7 +685,7 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+             return true
+         end if
+ 
+-        Debug("videoCanDirectPlay: mkv ac not aac/ac3/mp3")
++        Debug("videoCanDirectPlay: mkv ac not aac/ac3/mp3")
+         return false
+     end if
+ 
+@@ -758,7 +699,7 @@ Function videoCanDirectPlay(mediaItem) As Boolean
+         end if
+ 
+         if isnonemptystr(mediaItem.audioCodec) AND (mediaItem.audioCodec <> "aac" AND mediaItem.audioCodec <> "ac3" AND mediaItem.audioCodec <> "mp3") then
+-            Debug("videoCanDirectPlay: hls ac not aac/ac3/mp3")
++            Debug("videoCanDirectPlay: hls ac not aac/ac3/mp3")
+             'return false
+         end if
+ 
+diff --git Plex/source/ViewController.brs Plex/source/ViewController.brs
+index 51a86b6..a1b48cb 100644
+--- Plex/source/ViewController.brs
++++ Plex/source/ViewController.brs
+@@ -300,6 +300,9 @@ Function vcCreateVideoPlayer(metadata, seekValue=0, directPlayOptions=0, show=tr
+     ' Stop any background audio first
+     m.AudioPlayer.Stop()
+ 
++    ' Make sure we have full details before trying to play.
++    metadata.ParseDetails()
++
+     ' Prompt about resuming if there's an offset and the caller didn't specify a seek value.
+     if seekValue = invalid then
+         if metadata.viewOffset <> invalid then
+diff --git Plex/source/urlUtils.brs Plex/source/urlUtils.brs
+index 4481c7b..617dc6e 100644
+--- Plex/source/urlUtils.brs
++++ Plex/source/urlUtils.brs
+@@ -19,8 +19,6 @@ Function NewHttp(url As String) as Object
+     obj.PrepareUrlForQuery          = http_prepare_url_for_query
+     obj.GetToStringWithTimeout      = http_get_to_string_with_timeout
+ 
+-
+-
+     if Instr(1, url, "?") > 0 then obj.FirstParam = false
+ 
+     return obj
+--- README.md
++++ README.md
+@@ -44,6 +44,12 @@ There are some additional targets in the Makefile, like `make rel install` to
+ build a release, but you don't generally need them. One other nicety is the
+ ability to take a screenshot using `make screenshot`.
+ 
++**Note:** Some Roku versions are beginning to require HTTP authentication for
++the installer. This is somewhat handled, but not necessarily robustly, so
++you may need to make some tweaks. You can set environment variables for
++`ROKU_DEV_USERNAME` and `ROKU_DEV_PASSWORD`, which default to `rokudev` and
++`plex` respectively.
++
+ ### Debugging
+ 
+ The Roku doesn't have logging per se, but dev channels are able to write
+diff --git Release-Notes/2.6.8.en.txt Release-Notes/2.6.8.en.txt
+new file mode 100644
+index 0000000..0dd8fc1
+--- /dev/null
++++ Release-Notes/2.6.8.en.txt
+@@ -0,0 +1,8 @@
++NEW:
++  - Add transcode session info to the HUD.
++  - Add a toggle for DTS support.
++
++FIXES:
++  - Fix a crash in Playback Options for non-library content.
++  - Fix for Direct Playable content flung from iOS.
++  - Fix H.264 level preference.
+diff --git app.mk app.mk
+index cbab269..6af4c8e 100644
+--- app.mk
++++ app.mk
+@@ -25,6 +25,10 @@ PKGREL = ../packages
+ ZIPREL = ../zips
+ SOURCEREL = ..
+ 
++ROKU_DEV_USERNAME ?= rokudev
++ROKU_DEV_PASSWORD ?= plex
++CURL = curl --digest -u $(ROKU_DEV_USERNAME):$(ROKU_DEV_PASSWORD)
++
+ 
+ .PHONY: all $(APPNAME)
+ 
+@@ -64,7 +68,7 @@ $(APPNAME): $(APPDEPS)
+ 
+ install: $(APPNAME)
+ 	@echo "Installing $(APPNAME) to host $(ROKU_DEV_TARGET)"
+-	@curl -s -S -F "mysubmit=Install" -F "archive=@$(ZIPREL)/$(APPNAME).zip" -F "passwd=" http://$(ROKU_DEV_TARGET)/plugin_install | grep "<font color" | sed "s/<font color=\"red\">//"
++	@$(CURL) -s -S -F "mysubmit=Install" -F "archive=@$(ZIPREL)/$(APPNAME).zip" -F "passwd=" http://$(ROKU_DEV_TARGET)/plugin_install | grep "<font color" | sed "s/<font color=\"red\">//"
+ 
+ pkg: install
+ 	@echo "*** Creating Package ***"
+@@ -82,9 +86,9 @@ pkg: install
+ 	fi
+ 
+ 	@echo "Packaging  $(APPNAME) on host $(ROKU_DEV_TARGET)"
+-	@read -p "Password: " REPLY ; echo $$REPLY | xargs -i curl -s -S -Fmysubmit=Package -Fapp_name=$(APPNAME)/$(VERSION) -Fpasswd={} -Fpkg_time=`expr \`date +%s\` \* 1000` "http://$(ROKU_DEV_TARGET)/plugin_package" | grep '^<font face=' | sed 's/.*href=\"\([^\"]*\)\".*/\1/' | sed 's#pkgs/##' | xargs -i curl -s -S -o $(PKGREL)/$(APPNAME)_{} http://$(ROKU_DEV_TARGET)/pkgs/{}
++	@read -p "Password: " REPLY ; echo $$REPLY | xargs -i $(CURL) -s -S -Fmysubmit=Package -Fapp_name=$(APPNAME)/$(VERSION) -Fpasswd={} -Fpkg_time=`expr \`date +%s\` \* 1000` "http://$(ROKU_DEV_TARGET)/plugin_package" | grep '^<font face=' | sed 's/.*href=\"\([^\"]*\)\".*/\1/' | sed 's#pkgs/##' | xargs -i $(CURL) -s -S -o $(PKGREL)/$(APPNAME)_{} http://$(ROKU_DEV_TARGET)/pkgs/{}
+ 
+ 	@echo "*** Package  $(APPNAME) complete ***" 
+ remove:
+ 	@echo "Removing $(APPNAME) from host $(ROKU_DEV_TARGET)"
+-	@curl -s -S -F "mysubmit=Delete" -F "archive=" -F "passwd=" http://$(ROKU_DEV_TARGET)/plugin_install | grep "<font color" | sed "s/<font color=\"red\">//"
++	@$(CURL) -s -S -F "mysubmit=Delete" -F "archive=" -F "passwd=" http://$(ROKU_DEV_TARGET)/plugin_install | grep "<font color" | sed "s/<font color=\"red\">//"
